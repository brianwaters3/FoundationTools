/*
* Copyright (c) 2017 Sprint
* Copyright (c) 2019 Sprint
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#ifndef __EFD_H
#define __EFD_H

/// @file
///
/// @brief freeDiameter wrapper classes.
///
/// @details
///
/// # STARTUP, SHUTDOWN AND ADVERTISING SUPPORT FOR AN APPLICATION
///
///    Initialization of the freeDiameter library is achieved
///    by performing the following operations.
///
///    1. Create an instance of FDEngine that will exist for the
///       duration of the applciation.
///    2. Tell the freeDiameter library what configuration file to
///       use by calling FDEngine::setConfigFile().
///    3. Initialize the freeDiameter library by calling the
///       FDEngine::init() method.  This will only initialize the
///       library, it will not actually start communicating with other
///       diameter endpoints until the start() method is called.
///    4. Call FDEngine::advertiseSupport() for each supported diameter
///       application.  To populate the top level Auth-Application-Id or
///       Acct-Application-Id AVP in the Capabilities-Exchagne request or
///       answer, call the FDEngine::advertiseSupport() method that does
///       NOT accept a FDDictionaryEntryVendor object.  To populate the
///       the top level Vendor-Specific-Application-Id, use the
///       FDEngine::advertiseSupport() method that does accept a
///       FDDictionaryEntryVendor object.
///    5. After advertising support for all of the desired applications,
///       start freeDiameter by calling FDEngine::start().
///    6. At this point, freeDiameter is up and running.  The application
///       can wait for the freeDiameter engine to exit by calling
///       FDEngine::waitForShutdown().  This method will block until
///       freeDiameter has completed it's shutdown process.  The shutdown
///       process can be triggered by calling FDEngine::uninit() from any
///       thread or from a signal handler.
///
/// ## SENDING A REQUEST AND RECEIVING AN ANSWER
///
/// ### SENDING A REQUEST
///    Derive new class from FDMessageRequest overriding the
///    processAnswer() virtual method. the processAnswer()
///    method will be called when the answer is received.
///
///    If using the interface specific objects generated by
///    fdtool, it may be necessary to derive a new object
///    from the generated message specific request object,
///    ie s6t::COIRreq, in order to add additional data that
///    may be required when processing the answer.
///
///    1. "new" the derived FDMessageRequest object
///    2. Populate the appropriate AVP's
///    3. Send the request using the send() method
///       *** DO NOT DELETE THE REQUEST OBJECT ***
///
/// ### RECEIVING AN ANSWER
///    1. The processAnswer() virtual method will be called
///         with the context of the original derived FDMessageRequest
///         object.
///    2. Inside the processAnswer() virtual method, Create the
///         appropriate FDMessageAnswer (or derived) object and process
///         the answer accordingly.
///    3. When the FDMessageAnswer object goes out of scope (or is
///         deleted), the underlying freeDiameter message will be
///         freed.
///    4. After returning from the processAnswer() method, the
///         FDMessageRequest internals will delete the associated
///         FDMessageRequest object.
///
/// ## RECEIVING A REQUEST AND SENDING AN ANSWER
///
///   Unlike sending a request and receiving an answer where the
///   answer is processed by virtual method associated with the
///   request object, processAnswer(), to process an incoming
///   request, a command hander needs to be registered using the
///   FDApplication::registerHandler method.  If using the fdtool
///   generated interface specific objects, this can be done by
///   uncommenting the appropriate handler in the
///   Application::registerHandlers() method.  Then when an incoming
///   request is received the process() method associated with the
///   command object will be called to process the incoming request.
///
/// ### RECEIVING A REQUEST
///
///    1. The process() method of the previously registered command object
///       will be called by the framework.
///    2. Perform whatever processing is required to process the request.
///       If it is necessary to send a request to another application before
///       answering this request, make sure to save the FDMessageRequest*,
///       it will be needed to generate the answer.
///
/// ### SENDING AN ANSWER
///
///    1. Construct a FDMessageAnswer object by using the FDMessageRequest*
///       received in the command process() method.  The FDMessageAnswer can
///       be allocated on the stack, it does not need to be created on the heap
///       using "new".
///    2. After adding the necessary AVP's to the answer, send the answer message
///       by calling the FDMessageAnswer::send() method.
///    3. "delete" the FDMessageAnswer object if it was created using "new".
///
/// ## ADDING AVP'S TO A MESSAGE
///
///    AVP's can be added to a message by calling any of the overloaded
///    FDMessage::add() methods.  To add an AVP using a basic data type, the
///    FDDictionaryEntryAVP that describes the AVP must also be passed in to
///    the FDMessage::add() method.  Additionally, a previously FDAvp object
///    can be added using the FDMessage::add() method.  If it is necessary to
///    copy an AVP from one message to another, the FDMessage::add() method
///    will accept any of the FDExtractor objects (FDExtractor, FDExtractorList,
///    FDExtractorAvp or FDExtractorAvpList).
///
/// ## ADDING AVP'S TO A GROUPED AVP
///
///    First, create an FDAvp object using the appropriate FDDictionaryEntryAVP
///    object that describes the grouped AVP.  Then any AVP can be added to the
///    grouped AVP using the same overloads to the FDAvp::add() method that are
///    available in the FDMessage::add() methods.  Once all AVP's have been added
///    to the grouped AVP, add the grouped AVP to it's parent, another grouped AVP
///    or a message, using the add() method on the parent object.
///

#include <stddef.h>
#include <string.h>
#include <arpa/inet.h>
#include <time.h>

#include <stdexcept>
#include <string>
#include <list>
#include <map>

#include "freeDiameter/freeDiameter-host.h"
#include "freeDiameter/libfdcore.h"
#include "freeDiameter/libfdproto.h"

#include "ebase.h"
#include "estring.h"
#include "etime.h"
#include "etimer.h"
#include "eutil.h"

/// @brief Exception base class used within the freeDiameter wrapper classes.
class FDException : public std::runtime_error
{
public:
   /// @brief Class constructor.
   ///
   /// @param m the text associated with the exception.
   ///
   FDException(const char *m) : std::runtime_error(m) {}
   /// @brief Class constructor.
   ///
   /// @param m the text associated with the exception.
   ///
   FDException(const std::string &m) : std::runtime_error(m) {}
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template<class T>
class FDBuffer
{
public:
   FDBuffer(size_t size) { msize = size; mbuf = new T[msize]; }
   ~FDBuffer() { if (mbuf) delete [] mbuf; }
   T *get() { return mbuf; }
private:
   FDBuffer();
   size_t msize;
   T *mbuf;
};

class FDDictionaryEntryApplication;
class FDDictionaryEntryVendor;

/// @brief Provides an interface for controlling freeDiameter.
class FDEngine
{
public:
   /// @brief Class constructor.
   ///
   /// @param cfgfile the full path to the freeDiameter configuration file.
   ///
   FDEngine( const char *cfgfile = NULL );
   /// @brief Class constructor.
   ///
   /// @param cfgfile the full path to the freeDiameter configuration file.
   ///
   FDEngine( const std::string &cfgfile );
   /// @brief Class destructor
   ~FDEngine();

   /// @brief Initializes freeDiameter and loads the configuration file.
   /// @return True if initialization was successful, otherwise False.
   /// @throws FDException
   Bool init();
   /// @brief Starts freeDiameter.
   /// @return True if successful, otherwise False.
   /// @throws FDException
   Bool start();
   /// @brief Shuts down freeDiameter.
   Void uninit( Bool wait = true );
   /// @brief Waits for freeDiameter to shut down.
   Void waitForShutdown();

   /// @brief Retrieves the configuration file name..
   /// @return an EString reference containing the configuration file name.
   const EString &getConfigFile() { return m_cfgfile; }
   /// @brief Sets the configuration file.
   /// @param cf the new value for the configuration file.
   /// @return an EString reference containing the configuration file name.
   const EString &setConfigFile( const char *cf ) { return m_cfgfile = cf; }
   /// @brief Sets the configuration file.
   /// @param cf the new value for the configuration file.
   /// @return an EString reference containing the configuration file name.
   const EString &setConfigFile( const std::string &cf ) { return setConfigFile( cf.c_str() ); }

   /// @brief Configures a Diameter application to be advertised in the CER/CEA.
   /// @param app the dictionary entry associated with the application.
   /// @param auth indicates that this application is an authentication application.
   /// @param acct indicates that this application is an accounting application.
   /// @throws FDException
   Void advertiseSupport( FDDictionaryEntryApplication &app, Int auth = 0, Int acct = 0 );
   /// @brief Configures a vendor specific Diameter application to be advertised in the CER/CEA.
   /// @param app the dictionary entry associated with the application.
   /// @param vendor the dictionary entry associated with vendor.
   /// @param auth indicates that this application is an authentication application.
   /// @param acct indicates that this application is an accounting application.
   /// @throws FDException
   Void advertiseSupport( FDDictionaryEntryApplication &app, FDDictionaryEntryVendor &vendor, Int auth=0, Int acct=0 );
private:
   EString m_cfgfile;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// @brief A class wrapper around a freeDiameter dictionary entry.
///        This base class is not intended to be directly instantiated.
class FDDictionaryEntry
{
public:
   /// @brief Returns the freeDiameter dictionary structure pointer.
   /// @return the freeDiameter dictionary pointer.
   struct dictionary *getDictionary() const { return m_dict; }
   /// @brief Returns the freeDiameter dictionary entry structure pointer.
   /// @return the freeDiameter dictionary entry pointer.
   struct dict_object *getEntry() const { return m_de; }
   /// @brief Returns true if the dictionary entry is valid.
   /// @return True if this dictionary entry is valid, otherwise False.
   Bool isValid() { return m_de != NULL; }

protected:
   /// @brief Class constructor.
   FDDictionaryEntry();
   /// @brief Class constructor.
   /// @param what depending on criteria, the data that must be searched.
   /// @param type type of object that is being searched.
   /// @param criteria how the object must be searched.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   FDDictionaryEntry( const Void *what, enum dict_object_type type, Int criteria, struct dictionary *dict = NULL );

   /// @brief initializes an object created with the default constructor.
   /// @param what depending on criteria, the data that must be searched.
   /// @param type type of object that is being searched.
   /// @param criteria how the object must be searched.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   Void init( const Void *what, enum dict_object_type type, Int criteria, struct dictionary *dict = NULL );
   /// @brief intializes an object using an existing freeDiameter dictionary entry.
   /// @param de the dictionary entry to search.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   Void init( struct dict_object *de, struct dictionary *dict = NULL );

   /// @brief Class destructor.
   virtual ~FDDictionaryEntry();

private:

   struct dictionary *m_dict;
   struct dict_object *m_de;
   Bool m_destroy;
};

////////////////////////////////////////////////////////////////////////////////

/// @brief A dictionary entry object associated with an application.
class FDDictionaryEntryApplication : public FDDictionaryEntry
{
public:

   /// @brief Class constructor.
   /// @param name the name of the application.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryApplication( const char *name, struct dictionary *dict = NULL );

   /// @brief Returns the name of the application.
   /// @return the name of the application.
   const char *getName() const { return m_data.application_name; }
   /// @brief Returns the Diameter application ID of the application.
   /// @return the application ID of the applicaiton.
   application_id_t getId() const { return m_data.application_id; }

private:
   Bool init();

   dict_application_data m_data;
};

////////////////////////////////////////////////////////////////////////////////

/// @brief A dictionary entry object associated with a vendor.
class FDDictionaryEntryVendor : public FDDictionaryEntry
{
public:
   /// @brief Class constructor
   /// @param name the name of the vendor to search for.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryVendor( const char *name, struct dictionary *dict = NULL );
   /// @brief Class constructor
   /// @param vendorid the ID of the vendor to search for.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryVendor( vendor_id_t vendorid, struct dictionary *dict = NULL );
   /// @brief Class constructor
   /// @param app the application dictionary entry to retrieve the vendor for.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryVendor( const FDDictionaryEntryApplication &app, struct dictionary *dict = NULL );

   /// @brief Returns the name of the vendor.
   /// @return the name of the vendor.
   const char *getName() { return m_data.vendor_name; }
   /// @brief Returns the vendor ID associated with the vendor.
   /// @return the vendor ID of the vendor.
   vendor_id_t getId() { return m_data.vendor_id; }

private:
   Bool init();

   dict_vendor_data m_data;
};

////////////////////////////////////////////////////////////////////////////////

/// @brief The Diameter AVP data types.
enum DiameterDataType
{
   /// unknown/undefined
   DDTUnknown,
   /// octet string
   DDTOctetString,
   /// 32-bit integer
   DDTI32,
   /// 64-bit integer
   DDTI64,
   /// 32-bit unsigned integer
   DDTU32,
   /// 64-bit unsigned integer
   DDTU64,
   /// 32-bit floating point
   DDTF32,
   /// 64-bit floating point
   DDTF64,
   /// grouped AVP
   DDTGrouped,
   /// IP address
   DDTAddress,
   /// time value
   DDTTime,
   /// UTF-8 string (derived from octet string)
   DDTUTF8String,
   /// diameter identity (UTF-8 string)
   DDTDiameterIdentity,
   /// diameter URI
   DDTDiameterURI,
   /// enumerated type
   DDTEnumerated,
   /// IP filter rule
   DDTIPFilterRule
};

/// @brief A dictionary entry object associated with an AVP.
class FDDictionaryEntryAVP : public FDDictionaryEntry
{
public:
   /// @brief Class constructor.
   /// @param name the name of the AVP.
   /// @param allVendors indicates to whether to search all vendors or not.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryAVP( const char *name, Bool allVendors = false, struct dictionary *dict = NULL );
   /// @brief Class constructor.
   /// @param name the name of the AVP.
   /// @param vendorid the vendor ID of the AVP to search for.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryAVP( const char *name, vendor_id_t vendorid, struct dictionary *dict = NULL );
   /// @brief Class constructor.
   /// @param de the dictionary entry object to look up.
   /// @throws FDException
   FDDictionaryEntryAVP( struct dict_object *de );

   /// @brief Indicates whether the data type is derived from another or if it is a base data type.
   /// @return True if the data type is derived, False if it is a base data type.
   Bool isDerived() const { return m_isderived; }

   /// @brief Returns the AVP name.
   /// @return the name of the AVP.
   const char *getName() const { return m_basedata.avp_name; }
   /// @brief Returns the AVP vendor ID.
   /// @return the vendor ID for this AVP.
   vendor_id_t getVendorId() const { return m_basedata.avp_vendor; }
   /// @brief Returns the AVP code/ID.
   /// @return the AVP code/ID for this AVP.
   avp_code_t getAvpCode() const { return m_basedata.avp_code; }
   /// @brief Returns the data type of the AVP.
   /// @return the data type for this AVP.
   DiameterDataType getDataType() const { return m_datatype; }

private:
   Void getTypeInfo();
   
   std::string m_name;
   vendor_id_t m_vendorid;
   
   struct dict_avp_data m_basedata;
   struct dict_object *m_derivedtype;
   struct dict_type_data m_derivedtypedata;

   Bool m_isderived;
   DiameterDataType m_datatype;
};

////////////////////////////////////////////////////////////////////////////////

/// @brief A dictionary entry object associated with a command message.
class FDDictionaryEntryCommand : public FDDictionaryEntry
{
public:
   /// @brief Class constructor.
   /// @param name the name of the command.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryCommand( const char *name, struct dictionary *dict = NULL );
   /// @brief Class constructor.
   /// @param cmdid the ID of the command.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryCommand( command_code_t cmdid, struct dictionary *dict = NULL );
   /// @brief Class constructor.
   /// @param req the dictionary entry of the command.
   /// @param dict the dictionary to search.  If NULL, then globally defined freeDiameter dictionary will be searched.
   /// @throws FDException
   FDDictionaryEntryCommand( const FDDictionaryEntryCommand &req, struct dictionary *dict = NULL );

   /// @brief Returns True of the command is a request.
   /// @return True if the command is a request, otherwise False.
   Bool isRequest() const { return ( m_data.cmd_flag_val & CMD_FLAG_REQUEST ) ? true : false; } 
   /// @brief Returns True of the command is an answer.
   /// @return True if the command is an answer, otherwise False.
   Bool isAnswer() const { return ( m_data.cmd_flag_val & CMD_FLAG_REQUEST ) ? false : true; } 

   /// @brief Returns the command ID.
   /// @return the ID of the command.
   command_code_t getCommandCode() { return m_data.cmd_code; }
   /// @brief Returns the command name.
   /// @return the name of the command.
   const char *getName() { return m_data.cmd_name; }

private:
   struct dict_cmd_data m_data;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class FDMessage;
class FDExtractor;
class FDExtractorList;
class FDExtractorAvp;
class FDExtractorAvpList;

/// @brief A class wrapper around a freeDiameter AVP object.
class FDAvp
{
   friend FDMessage;

public:
   /// @brief Class constructor.
   /// @param de the dictionary entry for the AVP.
   /// @param dedel instructs the destructor to delete the dictionary entry.
   /// @throws FDException
   FDAvp( FDDictionaryEntryAVP &de, Bool dedel = false );
   /// @brief Class constructor.
   /// @param de the dictionary entry for the AVP.
   /// @param a the freeDiameter AVP pointer.
   /// @param dedel instructs the destructor to delete the dictionary entry.
   /// @throws FDException
   FDAvp( FDDictionaryEntryAVP &de, struct avp *a, Bool dedel = false );

   /// @brief Class destructor.
   ~FDAvp();

   /// @brief Adds an AVP to this grouped AVP.
   /// @param avp the AVP to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDAvp &avp );

   /// @brief Indicates if this AVP object is valid.
   /// @return True if this AVP object is associated with a freeDiameter AVP object, otherwise False.
   Bool isValid() { return m_avp != NULL; }

   /// @brief Adds an int32_t AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, int32_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an int64_t AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, int64_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an uint32_t AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, uint32_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an uint64_t AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, uint64_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a float AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, float v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a double AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, double v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a string AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, const char *v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a string to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, const std::string &v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an octet string AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @param len the length of the octet string.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, const char *v, size_t len ) { FDAvp avp( de ); avp.set( v, len ); return add( avp ); }
   /// @brief Adds an octet string AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @param len the length of the octet string.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, const uint8_t *v, size_t len ) { FDAvp avp( de ); avp.set( v, len ); return add( avp ); }
   /// @brief Adds a time AVP to this grouped AVP.
   /// @param de the dictionary entry for the AVP to add.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDDictionaryEntryAVP &de, const ETime &v ) { FDAvp avp( de ); avp = v; return add( avp ); }

   /// @brief Assigns an int32_t value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( int32_t v )              { return set( v ); }
   /// @brief Assigns an int64_t value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( int64_t v )              { return set( v ); }
   /// @brief Assigns an uint32_t value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( uint32_t v )             { return set( v ); }
   /// @brief Assigns an uint64_t value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( uint64_t v )             { return set( v ); }
   /// @brief Assigns a float value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( float v )                { return set( v ); }
   /// @brief Assigns a double value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( double v )               { return set( v ); }
   /// @brief Assigns a string value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( const char *v )          { return set( v ); }
   /// @brief Assigns a string value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( const std::string &v )   { return set( v ); }
   /// @brief Assigns a time value to this AVP.
   /// @param v the value to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &operator=( const ETime &v )         { return set( v ); }

   /// @brief Retrieves an int32_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( int32_t &v )                    { if ( m_avphdr == NULL ) return false; v = m_avphdr->avp_value->i32; return true; }
   /// @brief Retrieves an uint32_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint32_t &v )                   { if ( m_avphdr == NULL ) return false; v = m_avphdr->avp_value->u32; return true; }
   /// @brief Retrieves an uint64_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint64_t &v )                   { if ( m_avphdr == NULL ) return false; v = m_avphdr->avp_value->u64; return true; }
   /// @brief Retrieves a float AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( float &v )                      { if ( m_avphdr == NULL ) return false; v = m_avphdr->avp_value->f32; return true; }
   /// @brief Retrieves a double AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( double &v )                     { if ( m_avphdr == NULL ) return false; v = m_avphdr->avp_value->f64; return true; }
   /// @brief Retrieves an int64_t AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( int64_t &v );
   /// @brief Retrieves a string AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( std::string &v );
   /// @brief Retrieves an octet string AVP value.
   /// @param data the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( char *data, size_t &len );
   /// @brief Retrieves an octet string AVP value.
   /// @param data the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint8_t *data, size_t &len );
   /// @brief Retrieves an IP address AVP value.
   /// @param ss the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( sSS &ss );
   /// @brief Retrieves a time AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( ETime &v );

   /// @brief Assigns an int32_t value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( int32_t v )                    { m_value.i32 = v; assignValue(); return *this; }
   /// @brief Assigns an uint32_t value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( uint32_t v )                   { m_value.u32 = v; assignValue(); return *this; }
   /// @brief Assigns an uint64_t value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( uint64_t v )                   { m_value.u64 = v; assignValue(); return *this; }
   /// @brief Assigns a float value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( float v )                      { m_value.f32 = v; assignValue(); return *this; }
   /// @brief Assigns a double value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( double v )                     { m_value.f64 = v; assignValue(); return *this; }
   /// @brief Assigns a string value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( const char *v )                { return set( v, strlen( v ) ); }
   /// @brief Assigns an octet string value to this AVP.
   /// @param v the value to assign.
   /// @param len the length of the octet string.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( const uint8_t *v, size_t len ) { m_value.os.data = (uint8_t*)v; m_value.os.len = len; assignValue(); return *this; }
   /// @brief Assigns a string value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( const std::string &v )         { return set( v.c_str(), v.size() ); }
   /// @brief Assigns an int64_t value to this AVP.
   /// @param v the value to assign.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( int64_t v );
   /// @brief Assigns an octet string value to this AVP.
   /// @param v the value to assign.
   /// @param len the length of the octet string.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &set( const char *v, size_t len );
   /// @brief Assigns a time value to this AVP.
   /// @param v the value to assign.
   /// @throws FDException
   FDAvp &set( const ETime& v );

   /// @brief Returns the next AVP from a grouped AVP.
   /// @param found True if the next AVP is returned, False if no more AVP's are available.
   /// @return reference to the next AVP object.
   /// @throws FDException
   FDAvp getNext( Bool &found );
   /// @brief Returns the first child AVP of this grouped AVP.
   /// @param found True if the first child AVP is returned, False if there are no child AVP's are available.
   /// @return reference to the first child AVP object.
   /// @throws FDException
   FDAvp getChild( Bool &found );

   /// @brief Returns the underlying freeDiameter AVP object.
   /// @return pointer to the freeDiameter AVP object.
   struct avp *getAvp() { return m_avp; }
   /// @brief Returns the underlying freeDiameter AVP value object.
   /// @return pointer to the freeDiameter AVP value object.
   union avp_value *getAvpValue() { return &m_value; }
   /// @brief Sets the freeDiameter AVP object that this object is associated with.
   /// @return reference to this AVP object.
   FDAvp &setAvp( struct avp *a );

   /// @brief Adds the AVP's associated with the FDExtractor object to this AVP.
   /// @param e the FDExtractor object reference to copy.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDExtractor &e );
   /// @brief Adds the list of AVP's associated with the FDExtractorList object to this AVP.
   /// @param el the FDExtractorList object reference to copy.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDExtractorList &el );
   /// @brief Adds the AVP's associated with the FDExtractorAvp object to this AVP.
   /// @param ea the FDExtractorAvp object reference to copy.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDExtractorAvp &ea );
   /// @brief Adds the list of AVP's associated with the FDExtractorAvpList object to this AVP.
   /// @param eal the FDExtractorAvpList object reference to copy.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &add( FDExtractorAvpList &eal );

   /// @brief Adds the AVP's represented in a JSON string.
   /// @param json the JSON string containing the AVP values to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &addJson( const char *json );
   /// @brief Adds the AVP's represented in a JSON string.
   /// @param json the JSON string containing the AVP values to add.
   /// @return reference to this AVP object.
   /// @throws FDException
   FDAvp &addJson( const std::string &json ) { return addJson( json.c_str() ); }
   /// @brief Retrieves the JSON string representing the AVP values for this AVP.
   /// @param json the JSON string to populate.
   /// @return True if the JSON string was populated, otherwise False.
   Bool getJson( std::string &json );

   /// @brief Prints the contents of this AVP to the screen.
   Void dump();

   /// @brief Retrieves the dictionary entry associated with this FDAvp object.
   /// @return A reference to the AVP dictionary entry object.
   FDDictionaryEntryAVP &getDictionaryEntry() { return *m_de; }

protected:
   /// @brief Adds the contents of the message or avp to this AVP object.
   /// @param reference the message or avp to add.
   /// @throws FDException
   Void addTo( msg_or_avp *reference );

private:
   Void init();
   Void assignValue();

   FDDictionaryEntryAVP *m_de;
   struct avp *m_avp;
   struct avp_hdr *m_avphdr;
   union avp_value m_value;
   FDBuffer<uint8_t> *m_buf;
   Bool m_assigned;
   Bool m_dedel;
};

class FDMessageRequest;
class FDMessageAnswer;

/// @brief Represents a freeDiameter message.
class FDMessage
{
public:
   FDDictionaryEntryCommand *getCommand() { return m_de; }

   /// @brief Adds the contents of "avp" to this message.
   /// @param avp the AVP to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDAvp &avp ) { avp.addTo( m_msg ); return *this; }
   /// @brief Adds an int32_t value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, int32_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an int64_t value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, int64_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an uint32_t value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, uint32_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an uint64_t value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, uint64_t v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a float value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, float v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a double value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, double v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a string value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, const char *v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds a string value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, const std::string &v ) { FDAvp avp( de ); avp = v; return add( avp ); }
   /// @brief Adds an octet string value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @param len the length of the octet string to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, const char *v, size_t len ) { FDAvp avp( de ); avp.set( v, len ); return add( avp ); }
   /// @brief Adds an octet string value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @param len the length of the octet string to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, const uint8_t *v, size_t len ) { FDAvp avp( de ); avp.set( v, len ); return add( avp ); }
   /// @brief Adds a time value to this message.
   /// @param de the dictionary entry of the AVP to add.
   /// @param v the value to add.
   /// @return a reference to this message object.
   /// @throws FDException
   FDMessage &add( FDDictionaryEntryAVP &de, const ETime &v ) { FDAvp avp( de ); avp = v; return add( avp ); }

   /// @brief Adds the AVP's associated with the FDExtractor object to this AVP.
   /// @param e the FDExtractor object reference to copy.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &add( FDExtractor &e );
   /// @brief Adds the AVP's associated with the FDExtractorList object to this AVP.
   /// @param el the FDExtractor object reference to copy.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &add( FDExtractorList &el );
   /// @brief Adds the AVP's associated with the FDExtractorAvp object to this AVP.
   /// @param ea the FDExtractorAvp object reference to copy.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &add( FDExtractorAvp &ea );
   /// @brief Adds the AVP's associated with the FDExtractorAvpList object to this AVP.
   /// @param eal the FDExtractorAvpList object reference to copy.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &add( FDExtractorAvpList &eal );

   /// @brief Retrieves the int32_t AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, int32_t &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the int64_t AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, int64_t &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the uint32_t AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, uint32_t &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the uint64_t AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, uint64_t &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the float AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, float &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the double AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, double &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the string AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, std::string &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }
   /// @brief Retrieves the octet string AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, char *v, size_t &len ) { FDAvp avp = findAVP( de ); return avp.get( v, len ); }
   /// @brief Retrieves the octet string AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, uint8_t *v, size_t &len ) { FDAvp avp = findAVP( de ); return avp.get( v, len ); }
   /// @brief Retrieves the time AVP value associated with specified dictionary entry.
   /// @param de the dictionary entry of the AVP to retrieve.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( FDDictionaryEntryAVP &de, ETime &v ) { FDAvp avp = findAVP( de ); return avp.get( v ); }

   /// @brief Retrieves the AVP object specified by the dictionary entry from this message.
   /// @param de the AVP dictionary entry to search for.
   /// @return the FDAvp object.
   /// @throws FDException
   FDAvp findAVP( FDDictionaryEntryAVP &de );
   /// @brief Retrieves the first AVP object from this message.
   /// @param found indicates if the first entry was found.
   /// @return the FDAvp object.
   /// @throws FDException
   FDAvp getFirstAVP( Bool &found );

   /// @brief Prints the AVP contents of this message.
   Void dump();

   /// @brief Indicates if this message is a request.
   /// @return True if this message is a request, otherwise False.
   Bool isRequest() { return m_de->isRequest(); }
   /// @brief Indicates if this message is an answer.
   /// @return True if this message is an answer, otherwise False.
   Bool isAnswer() { return m_de->isAnswer(); }

   /// @brief Retrieves the freeDiameter message pointer.
   /// @return the freeDiameter message pointer.
   struct msg *getMsg() { return m_msg; }

   /// @brief Adds the Origin-Host and Origin-Realm to this message.
   /// @throws FDException
   Void addOrigin();

   /// @brief Adds the AVP's represented in the JSON string.
   /// @param json the JSON string.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &addJson( const char *json );
   /// @brief Adds the AVP's represented in the JSON string.
   /// @param json the JSON string.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &addJson( const std::string &json ) { return addJson( json.c_str() ); }
   /// @brief Retrieves a JSON string with all of the AVP's represented in it.
   /// @param json the JSON string object to populate.
   /// @return True if the AVP's were successfully converted to a string, otherwise False.
   Bool getJson( std::string &json );

protected:
   /// @brief Class constructor.
   /// @param req2ans indicates to construct an answer message based on the provided request message pointer.
   /// @param de the associated command dictionary entry.
   /// @param pmsg pointer to the freeDiameter message object.
   /// @param dedel indicates if the dictionary entry object is to be destroyed when this object is destroyed.
   /// @param msgdel indicates if the freeDiameter message object is to be free'ed when this object is destroyed.
   /// @throws FDException
   FDMessage( Bool req2ans, FDDictionaryEntryCommand *de, struct msg *pmsg = NULL, Bool dedel = false, Bool msgdel = true );
   /// @brief Class constructor.
   /// @param de the associated command dictionary entry.
   /// @param pmsg pointer to the freeDiameter message object.
   /// @param dedel indicates if the dictionary entry object is to be destroyed when this object is destroyed.
   /// @throws FDException
   FDMessage( FDDictionaryEntryCommand *de, struct msg *pmsg = NULL, Bool dedel = false );
   /// @brief Class constructor.
   /// @param ade the application dictionary entry.
   /// @param cde the associated command dictionary entry.
   /// @param pmsg pointer to the freeDiameter message object.
   /// @param dedel indicates if the dictionary entry object is to be destroyed when this object is destroyed.
   /// @throws FDException
   FDMessage( FDDictionaryEntryApplication *ade, FDDictionaryEntryCommand *cde, struct msg *pmsg = NULL, Bool dedel = false );
   /// @brief Class destructor.
   ~FDMessage();

   /// @brief Sends a request message.
   /// @param anscb an answer callback function pointer.
   /// @param req The request message to send.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &sendRequest( Void (*anscb)(Void*,struct msg**), FDMessageRequest &req );
   /// @brief Sends an answer message;
   /// @return reference to this message object.
   /// @throws FDException
   FDMessage &sendAnswer();
   
   /// @brief Sets value indicating if the freeDiameter message object is to be deleted when this object is destroyed.
   /// @param v True to delete the freeDiameter message pointer, otherwise False.
   Void setMsgDelete( Bool v ) { m_msgdel = v; }

private:
   FDMessage();

   FDDictionaryEntryCommand *m_de;
   Bool m_dedel;
   struct dict_cmd_data m_basedata;
   Bool m_msgdel;
   struct msg *m_msg;
};

/// @brief Represents a Diameter answer message (in rsponse to a request).
class FDMessageAnswer : public FDMessage
{
   friend FDMessageRequest;

public:
   /// @brief Class constructor.  Constructs the received answer message.
   /// @param req the request message to construct the answer to.
   /// @param pmsg the underlying freeDiameter answer message 
   /// @throws FDException
   FDMessageAnswer( FDMessageRequest *req, struct msg *pmsg ); // used to encapsulate a FD answer message
   /// @brief Class constructor.  Constructs an answer to be sent.
   /// @param req the request message to construct the answer to.
   /// @throws FDException
   FDMessageAnswer( FDMessageRequest *req ); // used to create and encapsulate a FD answer from a request
   /// @brief Class destructor.
   ~FDMessageAnswer();

   /// @brief Sends the answer.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessageAnswer &send();

private:
   FDMessageRequest *m_request;
};

/// @brief Represents a Diameter request message.
class FDMessageRequest : public FDMessage
{
   friend FDMessageAnswer;

public:
   /// @brief Class constructor.  Constructs a request to be sent.
   /// @param cde The dictionary entry for the request.
   /// @throws FDException
   FDMessageRequest( FDDictionaryEntryCommand *cde );
   /// @brief Class constructor.  Constructs a request that has been received.
   /// @param cde The dictionary entry for the request message.
   /// @param pmsg The underlying freeDiameter message.
   /// @throws FDException
   FDMessageRequest( FDDictionaryEntryCommand *cde, struct msg *pmsg );
   /// @brief Class constructor.  Constructs an application specific request that has been received.
   /// @param ade The dictionary entry for the application.
   /// @param cde The dictionary entry for the request message.
   /// @throws FDException
   FDMessageRequest( FDDictionaryEntryApplication *ade, FDDictionaryEntryCommand *cde );
   virtual ~FDMessageRequest();

   /// @brief Sends the request.
   /// @return reference to this message object.
   /// @throws FDException
   FDMessageRequest &send();

   /// @brief A virtual message that will process the answer message received in response to this request message.
   /// @param ans A reference to the answer message.
   virtual Void processAnswer( FDMessageAnswer &ans );

   /// @brief Sets indication whether to preserve the answer or not.
   /// @return the current value of the perserve flag.
   Bool setPreserveAnswer(Bool preserve) { return m_preserve_answer = preserve; }
   /// @brief Sets indication whether to preserve the answer or not.
   /// @return True indicates that the answer message will be preserved, otherwise False.
   Bool getPreserveAnswer() { return m_preserve_answer; }

protected:
   ETimer m_timer;

private:
   static Void anscb( Void * data, struct msg ** pmsg );

   Bool m_preserve_answer;
};

/// @brief Represents a command, a request or answer, that will be registered with freeDiameter.
class FDCommand
{
public:
   /// @brief The dictionary entry associated with the command.
   /// @return the command dictionary entry.
   FDDictionaryEntryCommand &getDictionaryEntry() { return m_de; }

   /// @brief Indicates if this command is a request (based on the dictionary entry).
   /// @return True indicates that the command is a request, otherwise False.
   virtual Bool isRequest() = 0;
   /// @brief Indicates if this command is an answer.
   /// @return True indicates that the command is a answer, otherwise False.
   Bool isAnswer() { return !isRequest(); }

protected:
   /// @brief Class constructor.
   /// @param de the dictionary entry associated with the command.
   FDCommand( FDDictionaryEntryCommand &de );

private:
   FDCommand();

   FDDictionaryEntryCommand &m_de;
};

/// @brief Represents a command request.
class FDCommandRequest : public FDCommand
{
public:
   /// @brief Class constructor.
   /// @param de the dictionary entry for the command.
   FDCommandRequest( FDDictionaryEntryCommand &de );

   /// @brief Indicates if this command is a request (based on the dictionary entry).
   /// @return True if this command is a request, otherwise False.
   Bool isRequest() { return true; }

   /// @brief Method that will process the request.
   /// @return integer value returned to freeDiameter.  0 indicates success, otherwise failure.
   virtual Int process( FDMessageRequest *req ) = 0;
};

/// @cond DOXYGEN_EXCLUDE
#define FDISREQUEST(hdr) ((hdr->msg_flags & CMD_FLAG_REQUEST) == CMD_FLAG_REQUEST)
#define FDISANSWER(hdr) ((hdr->msg_flags & CMD_FLAG_REQUEST) != CMD_FLAG_REQUEST)
/// @endcond

/// @brief Represents a Diameter application.
class FDApplication
{
public:
   /// @brief Class constructor.
   /// @param de the dictionary entry for the application.
   FDApplication( FDDictionaryEntryApplication *de );
   /// @brief Class destructor.
   ~FDApplication();

   /// @brief The dictionary entry for the application.
   /// @return The dictionary entry for the application.
   FDDictionaryEntryApplication &getDictionaryEntry() { return *m_de; }

   /// @brief Registers a message handler for a request command.
   /// @param cmd the request command to register.
   /// @return reference to this application object.
   FDApplication &registerHandler( FDCommandRequest &cmd );

protected:
   /// @brief Default class constructor
   FDApplication() : m_de( NULL ) {}
   /// @brief Retrieves the dictionary entry for the application.
   /// @return the dictionary entry for the application.
   FDDictionaryEntryApplication *setDictionaryEntry( FDDictionaryEntryApplication *de ) { return m_de = de; }

private:

   static Int commandcb( struct msg **m, struct avp *avp, struct session *session, Void *data, enum disp_action *action );

   FDDictionaryEntryApplication *m_de;
   std::list<FDCommandRequest*> m_cmds;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// @brief Allocates and assigns a Session-Id.
class FDSession
{
public:
   /// @brief Class constructor.
   FDSession();
   /// @brief Class destructor.
   ~FDSession();

   /// @brief Retrieves a string representation of the session ID.
   /// @return the session ID.
   const EString &getSessionId();
   /// @brief Adds the Session-Id to a message.
   /// @param msg the message to add the Session-Id to.
   /// @param deSessionId the dictionary entry for the session ID.
   Void addSessionId( FDMessage &msg, FDDictionaryEntryAVP &deSessionId );

private:
   Void init();

   struct session *m_session;
   EString m_sid;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// @brief Peer state enumerations.
enum FDPeerState
{
   /// Invalid or undefined state
   PSInvalid = -1,
   /// The peer has been just been created, PSM thread not started yet.
   PSNew = 0,
   /// Connection established.
   PSOpen,
   /// No connection established, will re-attempt after TcTimer.
   PSClosed,
   /// The connection is being shutdown (DPR/DPA in progress).
   PSClosing,
   /// Attempting to establish transport-level connection.
   PSWaitCnxAck,
   /// Received a CER from this same peer on an incoming connection (other peer object), while we were waiting for cnx ack.
   PSWaitCnxAckElec,
   /// Connection established, CER sent, waiting for CEA.
   PSWaitCEA,
   /// TLS Handshake and validation are in progress in open state -- we use it only for debug purpose, it is never displayed.
   PSOpenHandshake,
   /// A DWR was sent and not answered within TwTime. Failover in progress.
   PSSuspect,
   /// Connection has been re-established, waiting for 3 DWR/DWA exchanges before putting back to service.
   PSReOpen,
   /// After CEA is sent, until a new message is received. Force ordering in this state.
   PSOpenNew,
   /// After DPA is sent or received, give a short delay for messages in the pipe to be received.
   PSClosingGrace,
   /// The PSM thread is not running anymore; it must be re-started or peer should be deleted.
   PSZombie
};

/// @brief Represents a Diameter peer.
class FDPeer
{
public:
   /// @brief Class constructor.
   FDPeer();
   /// @brief Class constructor.
   /// @param diamid the Diameter ID of the peer.
   /// @param port the IP port of the peer.
   FDPeer( DiamId_t diamid, uint16_t port = 3868 );
   /// @brief Class constructor.
   /// @param diamid the Diameter ID of the peer.
   /// @param port the IP port of the peer.
   FDPeer( const std::string &diamid, uint16_t port = 3868 );

   /// @brief Retrieves the Diameter ID of the peer.
   /// @return the Diameter ID of the peer.
   const std::string &getDiameterId() { return m_diamid; }
   /// @brief Assigns the Diameter ID for this peer object.
   /// @param diamid the Diameter ID of the peer.
   /// @return reference to this peer object.
   FDPeer &setDiameterId( DiamId_t diamid ) { m_diamid = diamid; return *this; }

   /// @brief Retrieves the IP port for this peer.
   /// @return the IP port value.
   uint16_t getPort() { return m_port; }
   /// @brief Assigns the IP port for this peer.
   /// @param v the new IP Port value to assign.
   /// @return reference to this peer object.
   FDPeer &setPort( uint16_t v ) { m_port = v; return *this; }

   /// @brief Retrieves the distination host for this peer.
   /// @return the destination host for this peer.
   const EString &getDestinationHost() const { return m_diamid; }
   /// @brief Retrieves the distination realm for this peer.
   /// @return the destination realm for this peer.
   const EString &getDestinationRealm() const { return m_destrealm; }

   /// @brief Assigns the peer's IP address.
   /// @param ip the peer IP address.
   /// @return the peer IP address.
   const EString &setDestinationIp( const char *ip ) { m_destip = ip; return getDestinationIp(); }
   /// @brief Assigns the peer's IP address.
   /// @param ip the peer IP address.
   /// @return the peer IP address.
   const EString &setDestinationIp( const std::string &ip ) { m_destip = ip; return getDestinationIp(); }
   /// @brief Retrieves the peer's IP address.
   /// @return the peer IP address.
   const EString &getDestinationIp() const { return m_destip; }

   /// @brief Retrieves the peer connection state.
   /// @return the peer connection state.
   FDPeerState getState();

   /// @brief Indicates if the connection to the peer is open.
   /// @return True indicates that the connection is open, otherwise False.
   Bool isOpen() { return getState() == PSOpen; }

   /// @brief Adds the peer to freeDiameter.
   Void add();

private:
   Void init();
   static Void peercb( struct peer_info *pi, Void *data );

   EString m_diamid;
   EString m_destrealm;
   EString m_destip;
   uint16_t m_port;
   struct peer_hdr *m_peer;
};

/// @brief A list of FDPeer objects.
class FDPeerList : public std::list<FDPeer*>
{
public:
   /// @brief Class constructor.
   FDPeerList();
   /// @brief Class destructor.
   ~FDPeerList();

   /// @brief Indicates if the peer is in an open state.
   /// @return True if the peer is in an open state, otherwise False.
   Bool isPeerOpen();

   /// @brief Retrieves the first peer that is an open state.
   /// @return Pointer to the open peer.
   FDPeer *getOpenPeer();
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class FDExtractorAvp;

/// @brief Defines the types of extractors.
enum eFDExtractorType
{
   /// represents an AVP extractor
   etAvp,
   /// represents an AVP list extractor
   etAvpList,
   /// represents an extractor (grouped AVP)
   etExtractor,
   /// represents an extractor list (grouped AVP)
   etExtractorList
};

/// @brief Extractor base class. An extractor is a wrapper around an AVP that locates and accesses the AVP in the message or grouped AVP.
class FDExtractorBase
{
public:
   /// @brief Class constructor.
   /// @param de the dictionary entry for this extractor.
   FDExtractorBase( FDDictionaryEntryAVP *de )
      : m_de( de ),
        m_idx( -1 ),
        m_resolved( false )
   {
   }

   /// @brief Class destructor.
   virtual ~FDExtractorBase()
   {
   }

   /// @brief Retrieves the type of this extractor.
   /// @return the extractor type.
   virtual eFDExtractorType getExtractorType() = 0;

   /// @brief Retrieves the location of the AVP in the parent (message or AVP).
   /// @return the index of this AVP.
   Int getIndex() { return m_idx; }
   /// @brief Assigns the index of this AVP.
   /// @param idx the index of the AVP in the message or grouped AVP.
   /// @return the assigned index.
   Int setIndex( Int idx ) { return m_idx = idx; }

   /// @brief Retrieves the resolved status.  Being resolved means that the underlying freeDiameter AVP has been located and assigned.
   /// @return True if resolved, otherwise False.
   Bool getResolved() { return m_resolved; }
   /// @brief Assigns the resolved state.
   /// @param resolved the resolutions status to assign.
   /// @return True if resolved, otherwise False.
   Bool setResolved( Bool resolved = true ) { return m_resolved = resolved; }

   /// @brief Retrieves status indicating if the AVP is present/exists in the message.
   /// @return True if the AVP exists, otherwise False.
   Bool exists() { return m_idx != -1; }

   /// @brief Retrieves the dictionary entry associated with the AVP.
   /// @return the AVP dictionary entry.
   FDDictionaryEntryAVP *getDictionaryEntry() { return m_de; }

private:
   FDDictionaryEntryAVP *m_de;
   Int m_idx;
   Bool m_resolved;
};

/// @brief Used as the key to a collection of extractors.
class FDExtractorKey
{
public:
   /// @brief Class constructor.
   FDExtractorKey()
      : m_vndid( 0 ),
        m_avpcode( 0 )
   {
   }

   /// @brief Class constructor.
   /// @param v the vendor ID for the key.
   /// @param a the AVP code for the key.
   FDExtractorKey( vendor_id_t v, avp_code_t a )
      : m_vndid( v ),
        m_avpcode( a )
   {
   }

   /// @brief Copy constructor.
   /// @param k the key object to copy.
   FDExtractorKey( const FDExtractorKey &k )
      : m_vndid( k.m_vndid ),
        m_avpcode( k.m_avpcode )
   {
   }

   /// @brief Class destructor.
   virtual ~FDExtractorKey()
   {
   }

   /// @brief Determins if the provided extractor key is less than this extractor key.
   /// @param rval the right hand value to evaluate.
   /// @return True indicating that the provided key is less than this key, otherwise False.
   Bool operator <(const FDExtractorKey &rval ) const
   {
      return
         m_vndid < rval.m_vndid ? True :
         m_vndid > rval.m_vndid ? False : m_avpcode < rval.m_avpcode;
   }

   /// @brief Retrieves the vendor ID.
   /// @return the vendor ID of this key.
   vendor_id_t getVendor() { return m_vndid; }
   /// @brief Assigns the vendor ID.
   /// @param v the vendor ID to assign.
   /// @return the assigned vendor ID.
   vendor_id_t setVendor( vendor_id_t v ) { return m_vndid = v; }

   /// @brief Retrieves the AVP code.
   /// @return the AVP code of this key.
   avp_code_t getAvpCode() { return m_avpcode; }
   /// @brief Assigns the AVP code.
   /// @param a the AVP code to assign.
   /// @return the assigned AVP code.
   avp_code_t setAvpCode( avp_code_t a ) { return m_avpcode = a; }

private:
   vendor_id_t m_vndid;
   avp_code_t m_avpcode;
};

/// @brief A wrapper around a grouped AVP used to locate and access the AVP's in the parent message or grouped AVP.
class FDExtractor : public FDExtractorBase
{
   friend FDExtractorList;
   friend FDExtractorAvp;
   friend FDExtractorAvpList;

public:
   /// @brief Default constructor.
   FDExtractor();
   /// @brief Constructs an extractor from a message (answer or request).
   /// @param msg the message to encapsulate.
   FDExtractor( FDMessage &msg );
   /// @brief Class constructor.
   /// @param de the command dictionary entry for this extractor.
   FDExtractor( FDDictionaryEntryCommand &de );
   /// @brief Class constructor.
   /// @param parent the parent extractor object.
   /// @param de the AVP dictionary entry for this extractor.
   FDExtractor( FDExtractor &parent, FDDictionaryEntryAVP &de );
   /// @brief Class destructor.
   virtual ~FDExtractor();

   /// @brief Retrieves the extractor type.
   /// @return the extractor type.
   eFDExtractorType getExtractorType() { return etExtractor; }

   /// @brief Assigns the reference that this extractor is associated wtih.
   /// @param msg a message reference.
   Void setReference( FDMessage &msg ) { m_reference = msg.getMsg(); }
   /// @brief Assigns the reference that this extractor is associated wtih.
   /// @param avp a AVP reference.
   Void setReference( FDAvp &avp )     { m_reference = avp.getAvp(); }
   /// @brief Assigns the reference that this extractor is associated wtih.
   /// @param m a freeDiameter AVP or message pointer.
   Void setReference( msg_or_avp *m )  { m_reference = m; }

   /// @brief retrieves the parent of this extractor.
   /// @return pointer to the parent extractor.
   FDExtractor *getParent() { return m_parent; }
   /// @brief retrieves the freeDiameter reference for this extractor.
   /// @return the freeDiameter message or AVP reference pointer.
   msg_or_avp *getReference();

   /// @brief Adds a child extractor to this extractor.
   Void add( FDExtractorBase &base );

   /// @brief Determines if this extractor exists in the underlying freeDiameter message or grouped AVP.
   /// @return True if the AVP has been found in the message or grouped AVP.
   Bool exists( Bool skipResolve = false );

   /// @brief Prints the underlying freeDiameter message or AVP to stdout.
   Void dump();

   /// @brief Retrieves a JSON representation of the message or AVP.
   /// @param json the destination for the JSON representation.
   /// @return True if the message or AVP was successfully converted to JSON, otherwise False.
   Bool getJson( std::string &json );

protected:
   /// @brief Locates this AVP in the freeDiameter message or grouped AVP.
   Void resolve();

private:
   FDExtractor *m_parent;
   msg_or_avp *m_reference;
   std::map<FDExtractorKey,FDExtractorBase*> m_entries;
   Int m_index;
};

/// @brief A wrapper around a grouped AVP that can occur multiple times.
class FDExtractorList : public FDExtractorBase
{
   friend FDExtractor;
   friend FDAvp;
   friend FDMessage;

public:
   /// @brief Class constructor.
   /// @param parent the parent extractor object.
   /// @param de the dictionary entry for this extractor.
   FDExtractorList( FDExtractor &parent, FDDictionaryEntryAVP &de );
   /// @brief Class destructor.
   virtual ~FDExtractorList();

   /// @brief Retrieves the extractor type.
   /// @return the extractor type.
   eFDExtractorType getExtractorType() { return etExtractorList; }

   /// @brief Retrieves the parent extractor object.
   /// @return the parent extractor object.
   FDExtractor &getParent() { return *m_parent; }

   /// @brief Virtual method to create an extractor list member object.
   /// @return the created extractor object.
   virtual FDExtractor *createExtractor() = 0;

   /// @brief Adds an extractor to the list.
   /// @param e the extractor to add.
   Void addExtractor( FDExtractor *e );

   /// @brief Determines if this extractor exists in the underlying freeDiameter message or grouped AVP.
   /// @return True if the AVP has been found in the message or grouped AVP.
   Bool exists();

   /// @brief Prints the underlying freeDiameter message or AVP to stdout.
   Void dump();

protected:
   /// @brief Retrieves the extractor list.
   /// @return the extractor list.
   std::list<FDExtractor*> &getList();

private:
   FDExtractorList();

   FDExtractor *m_parent;
   std::list<FDExtractor*> m_list;
};

/// @brief An AVP extractor object.
class FDExtractorAvp : public FDExtractorBase
{
public:
   /// @brief Class constructor.
   /// @param extractor the parent extractor.
   /// @param de the dictionary for this AVP extractor.
   /// @param dedel indicates if the dictionary entry object is to be destroyed when this object is destroyed.
   FDExtractorAvp( FDExtractor &extractor, FDDictionaryEntryAVP &de, Bool dedel = false );
   /// @brief Class destructor.
   virtual ~FDExtractorAvp();

   /// @brief Retrieves the extractor type.
   /// @return the extractor type.
   eFDExtractorType getExtractorType() { return etAvp; }

   /// @brief Assigns the underlying freeDiameter AVP to this extractor.
   /// @param a the underlying freeDiameter AVP pointer.
   Void setAvp( struct avp *a ) { m_avp.setAvp( a ); }
   /// @brief Retrieves the underlying freeDiameter AVP pointer.
   /// @return the underlying freeDiameter AVP pointer.
   struct avp *getAvp() { return m_avp.getAvp(); }
   /// @brief Retrieves the underlying freeDiameter AVP value pointer.
   /// @return the underlying freeDiameter AVP value pointer.
   union avp_value *getAvpValue() { return m_avp.getAvpValue(); }

   /// @brief Determines if this extractor exists in the underlying freeDiameter message or grouped AVP.
   /// @return True if the AVP has been found in the message or grouped AVP.
   Bool exists();

   /// @brief Retrieves an int32_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( int32_t &v )                    { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves an uint32_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint32_t &v )                   { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves an uint64_t AVP value. Returns True if the value is successfully retrieved.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint64_t &v )                   { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves a float AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( float &v )                      { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves a double AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( double &v )                     { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves an int64_t AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( int64_t &v )                    { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves a string AVP value.
   /// @param v the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( std::string &v )                { if ( !exists() ) return false; return m_avp.get( v ); }
   /// @brief Retrieves an octet string AVP value.
   /// @param data the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( char *data, size_t &len )       { if ( !exists() ) return false; return m_avp.get( data, len ); }
   /// @brief Retrieves an octet string AVP value.
   /// @param data the variable to populate.
   /// @param len the maximum length of the octet string.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( uint8_t *data, size_t &len )    { if ( !exists() ) return false; return m_avp.get( data, len ); }
   /// @brief Retrieves an IP address AVP value.
   /// @param ss the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   Bool get( sSS &ss )                       { if ( !exists() ) return false; return m_avp.get( ss ); }
   /// @brief Retrieves a time AVP value.
   /// @param t the variable to populate.
   /// @return True if the value was retrieved, otherwise False.
   /// @throws FDException
   Bool get( ETime &t )                      { if ( !exists() ) return false; return m_avp.get( t ); }

   /// @brief Prints the contents of this AVP to the screen.
   Void dump();

   /// @brief Retrieves the JSON string representing the AVP values for this AVP.
   /// @param json the JSON string to populate.
   /// @return True if the JSON string was populated, otherwise False.
   Bool getJson( std::string &json );

private:
   FDExtractor &m_extractor;
   FDAvp m_avp;
};

/// @brief An extractor for an AVP that can have multiple occurrances.
class FDExtractorAvpList : public FDExtractorBase
{
public:
   /// @brief Class constructor.
   /// @param extractor the parent extractor.
   /// @param de the associated dictionary entry.
   FDExtractorAvpList( FDExtractor &extractor, FDDictionaryEntryAVP &de );
   /// @brief Class destructor.
   virtual ~FDExtractorAvpList();

   /// @brief Retrieves the extractor type.
   /// @return the extractor type.
   eFDExtractorType getExtractorType() { return etAvpList; }

   /// @brief Retrieves the list of extractors.
   /// @return the extractor list.
   std::list<FDExtractorAvp*> &getList();

   /// @brief Determines if this extractor exists in the underlying freeDiameter message or grouped AVP.
   /// @return True if the AVP has been found in the message or grouped AVP.
   Bool exists();

   /// @brief Prints the underlying freeDiameter message or AVP to stdout.
   Void dump();

private:
   FDExtractorAvpList();

   FDExtractor *m_parent;
   std::list<FDExtractorAvp*> m_list;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// @brief Registers, unregisters and process freeDiameter hooks.  See "MONITORING" in libfdcore.h in the freeDiameter library.
class FDHook
{
public:
   /// @brief Class constructor.
   FDHook();

   /// @brief Method that is called to process a freeDiameter hook callback.
   /// @param type the type of hook that triggered this call, in case same cb is registered for several hooks.
   /// @param msg if relevant, the pointer to the message triggering the call. NULL otherwise.
   /// @param peer if relevant, the pointer to the peer associated with the call. NULL otherwise.
   /// @param other for some callbacks, the remaining information is passed in this parameter. See each hook detail.
   /// @param pmd structure associated with a given message, across several hooks.
   virtual Void process(enum fd_hook_type type, struct msg * msg, struct peer_hdr * peer,
      Void * other, struct fd_hook_permsgdata *pmd) = 0;

   /// @brief Registers the hook for the specified events.   
   Bool registerHook(UInt hookmask);
   /// @brief Unregisters the hook.
   Void unregisterHook();

   /// @brief Retrieves the hook handle.
   /// @return the hook handle.
   struct fd_hook_hdl *getHandle() { return m_hdl; }

   /// @brief Retrieves the hook mask.
   /// @return the hook mask.
   UInt getHookMask() { return m_hookmask; }

private:
   static Void hook_cb(enum fd_hook_type type, struct msg * msg, struct peer_hdr * peer,
      Void * other, struct fd_hook_permsgdata *pmd, Void * regdata);
   
   UInt m_hookmask;
   struct fd_hook_hdl *m_hdl;
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// @brief Various Diameter utility functions.
class FDUtility
{
public:
   /// @brief Splits a fully qualified domain name into host and realm.
   /// @param fqdn the fully qualified domain name.
   /// @param host the resulting host.
   /// @param realm the resulting realm.
   static Void splitDiameterFQDN( std::string &fqdn, std::string &host, std::string &realm );
   /// @brief Splits a fully qualified domain name into host and realm.
   /// @param fqdn the fully qualified domain name.
   /// @param host the resulting host.
   /// @param realm the resulting realm.
   static Void splitDiameterFQDN( const char *fqdn, std::string &host, std::string &realm ) { std::string sfqdn( fqdn ); splitDiameterFQDN( sfqdn, host, realm ); }

   /// @brief Converts a series of digits to telephony binary coded decimal.
   /// @param src the source string containing the digits.
   /// @param srclen the length of the source string.
   /// @param dst the destination where the TBCD value will be stored.
   /// @param dstlen the maximum length of the TBCD value.
   /// @return the length of the TBCD encoded value.
   static size_t str2tbcd( const char *src, size_t srclen, uint8_t *dst, size_t dstlen );
   /// @brief Converts a series of digits to telephony binary coded decimal.
   /// @param src the source NULL terminated string containing the digits.
   /// @param dst the destination where the TBCD value will be stored.
   /// @param dstlen the maximum length of the TBCD value.
   /// @return the length of the TBCD encoded value.
   static size_t str2tbcd( const char *src, uint8_t *dst, size_t dstlen );
   /// @brief Converts a series of digits to telephony binary coded decimal.
   /// @param src the string containing the digits.
   /// @param dst the destination where the TBCD value will be stored.
   /// @param dstlen the maximum length of the TBCD value.
   /// @return the length of the TBCD encoded value.
   static size_t str2tbcd( const std::string &src, uint8_t *dst, size_t dstlen );

   /// @brief Converts a TBCD value to a series of digits.
   /// @param src the source TBCD value.
   /// @param srclen the length of the TBCD value in bytes.
   /// @param dst the destination where the digits will be stored.
   /// @param dstlen the maximum length of the buffer where the digits will be stored.
   /// @return the length of the string of digits.
   static size_t tbcd2str( uint8_t *src, size_t srclen, char *dst, size_t dstlen );
   /// @brief Converts a TBCD value to a series of digits.
   /// @param src the source TBCD value.
   /// @param srclen the length of the TBCD value in bytes.
   /// @param dst the destination where the digits will be stored.
   /// @return the length of the string of digits.
   static size_t tbcd2str( uint8_t *src, size_t srclen, std::string &dst );
};

#endif // #define __EFD_H
