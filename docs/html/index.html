<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpcTools: Enhanced Packet Core Application Development Tools for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EpcTools
   </div>
   <div id="projectbrief">An event based multi-threaded C++ development framework.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Enhanced Packet Core Application Development Tools for Linux </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> is a set of C++ classes that simplifies the development and management of EPC applications. This library is intended for use on any Linux based system that supports g++ and pthreads.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Contents</h1>
<div class="mycustomlist"> <ol>
<li>
<a href="#dependencies">Dependencies</a> </li>
<li>
<a href="#installation">Installation</a> </li>
<li>
<a href="#configuration">Configuration</a> <ol>
<li>
<a href="#configuration-command-line">Command Line</a> </li>
<li>
<a href="#configuration-file">Configuration File</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview">Feature Overview</a> <ol>
<li>
<a href="#feature-overview-public-private">Public vs. Private</a> </li>
<li>
<a href="#feature-overview-shared-memory">Shared Memory</a> </li>
<li>
<a href="#feature-overview-threads">Threads</a> <ol>
<li>
<a href="#feature-overview-threads-basic-thread">Basic Thread</a> </li>
<li>
<a href="#feature-overview-threads-event-thread">Event Thread</a> <ol>
<li>
<a href="#feature-overview-threads-event-thread-queue">Event Queues</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-message">Event Message</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-message-custom">Custom Event Message</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-event-processing">Event Processing</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-timers">Timers</a> </li>
<li>
<a href="#feature-overview-threads-event-thread-example">Example</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-threads-public-event-threads">Public Event Threads</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-message-queue">Message Queue</a> <ol>
<li>
<a href="#feature-overview-message-queue-pack-unpack">Pack/Unpack</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-synchronization">Synchronization</a> <ol>
<li>
<a href="#feature-overview-synchronization-mutex">Mutex</a> </li>
<li>
<a href="#feature-overview-synchronization-semaphore">Semaphore</a> </li>
<li>
<a href="#feature-overview-synchronization-event">Event</a> </li>
<li>
<a href="#feature-overview-synchronization-read-write-lock">Read/Write Lock</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-socket-communications">Socket Communications</a> <ol>
<li>
<a href="#feature-overview-socket-communications-socket-thread">Socket Thread</a> </li>
<li>
<a href="#feature-overview-socket-communications-tcp">TCP</a> </li>
<li>
<a href="#feature-overview-socket-communications-udp">UDP</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-logging">Logging</a> </li>
<li>
<a href="#feature-overview-dns">DNS</a> <ol>
<li>
<a href="#feature-overview-dns-cache">Cache</a> </li>
<li>
<a href="#feature-overview-dns-epc-node-discovery">EPC Node Discovery</a> </li>
<li>
<a href="#feature-overview-dns-diameter-s-naptr">Diameter S-NAPTR</a> </li>
</ol>
</li>
<li>
<a href="#feature-overview-rest-server">REST Server</a> </li>
<li>
<a href="#feature-overview-freediameter">freeDiameter</a> </li>
<li>
<a href="#feature-overview-statistics">Interface Statistics</a> </li>
<li>
<a href="#feature-overview-timer-pool">Timer Pool</a> </li>
<li>
<a href="#feature-overview-miscellaneous">Miscellaneous</a> <ol>
<li>
<a href="#feature-overview-miscellaneous-string">String</a> </li>
<li>
<a href="#feature-overview-miscellaneous-utilities">Utilities</a> </li>
<li>
<a href="#feature-overview-miscellaneous-time">Time</a> </li>
<li>
<a href="#feature-overview-miscellaneous-timer">Timer</a> </li>
<li>
<a href="#feature-overview-miscellaneous-path">Path</a> </li>
<li>
<a href="#feature-overview-miscellaneous-directory">Directory</a> </li>
<li>
<a href="#feature-overview-miscellaneous-error">Error</a> </li>
<li>
<a href="#feature-overview-miscellaneous-hash">Hash</a> </li>
<li>
<a href="#feature-overview-miscellaneous-bzip2">BZip2</a> </li>
<li>
<a href="#feature-overview-miscellaneous-circular-buffer">Circular Buffer</a> </li>
</ol>
</li>
</ol>
</li>
</ol>
</div><p><a class="anchor" id="dependencies"></a> </p>
<h1><a class="anchor" id="autotoc_md11"></a>
Dependencies</h1>
<ul>
<li><a href="https://github.com/omec-project/freediameter">freeDiameter</a> - an implementation of the Diameter protocol</li>
<li><a href="http://rapidjson.org">RapidJSON</a> - a JSON parser and generator for C++</li>
<li><a href="https://github.com/gabime/spdlog">spdlog</a> - very fast, header-only/compiled, C++ logging library</li>
<li><a href="http://pistache.io/">pistache</a> - an elegant C++ REST framework</li>
<li><a href="https://www.sourceware.org/bzip2/">bzip2</a> - a freely available, patent free (see below), high-quality data compressor</li>
</ul>
<p><a class="anchor" id="installation"></a> </p>
<h1><a class="anchor" id="autotoc_md12"></a>
Installation</h1>
<p><em><b>Update your system.</b></em> </p><div class="fragment"><div class="line">$ sudo apt-get update</div>
</div><!-- fragment --><p> <em><b>Install Ubuntu 16.04 prerequisites.</b></em> </p><div class="fragment"><div class="line">sudo apt-get install mercurial cmake make gcc g++ bison flex libsctp-dev libgnutls-dev libgcrypt-dev libidn11-dev m4 automake libtool</div>
</div><!-- fragment --><p>  <em><b>Install Ubuntu 18.04 prerequisites.</b></em> </p><div class="fragment"><div class="line">sudo apt-get install mercurial cmake make gcc g++ bison flex libsctp-dev libgnutls28-dev libgcrypt-dev libidn11-dev m4 automake libtool</div>
</div><!-- fragment --><p> <em><b>Clone the project, install the dependencies (via configure), build the static library and install.</b></em> </p><div class="fragment"><div class="line">$ git clone https://github.com/brianwaters3/FoundationTools.git epctools</div>
<div class="line">$ cd epctools</div>
<div class="line">$ git checkout sprint</div>
<div class="line">$ ./configure</div>
<div class="line">$ make</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview"></a> </p>
<h1><a class="anchor" id="autotoc_md13"></a>
Feature Overview</h1>
<p><a class="anchor" id="feature-overview-public-private"></a> </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Public vs. Private</h2>
<p>For some classes, <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> supports the concept of public classes and private. A public class/object is one that can be accessed from a different process, while a private class/object can only be accessed from within the current process. This is achieved by storing the data associated with the public object in shared memory, thereby giving access to the public objects to any process.</p>
<p><em><b>NOTE:</b></em> Since public objects have data stored in shared memory, each application that wants to have access to the public object must enable the EpcTools/EnablePublicObjects configuration option to TRUE. By default, the EpcTools/EnablePublicObjects configuration option is <code>FALSE</code>. Additionally, if an application does not call <a class="el" href="classEpcTools.html#a3c6f9a52b98c9452d2ec05c8b923087f">EpcTools::UnInitialize()</a> prior to exiting, the objects in shared memory will be remain until the shared memory is released. <em><b>This condition can lead to unexpected/unexplained application behavior.</b></em></p>
<p>The classes that support public/private are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Public  </th><th class="markdownTableHeadLeft">Private  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEMutexPublic.html">EMutexPublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classEMutexPrivate.html">EMutexPrivate</a>  </td><td class="markdownTableBodyLeft">A mutex (mutual exclusion object) is a program object that is created so that multiple threads can take turns sharing the same resource, such as a file or list. An application can attach to a public mutex specifying the mutex ID when calling the <a class="el" href="classEMutexPublic.html#ab7ba904a8f25286d03118efaee635e84">attach()</a> method.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePublic.html">ESemaphorePublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classESemaphorePrivate.html">ESemaphorePrivate</a>  </td><td class="markdownTableBodyLeft">A semaphore is simply a variable which is non-negative and shared between threads. The <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> semaphore is what is considered a counting semaphore. Semaphores are used internally in <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> as part of various queue implementations to represent the number of messages in the queue. If you attempt to read a queue that is empty, the semaphore will block until a message has been added to the queue. An application can attach to a public semaphore by specifying the semaphore ID when calling the <a class="el" href="classESemaphorePublic.html#a0cbb272ad36c64680929076e32440940">attach()</a> method.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="classEQueuePublic.html">EQueuePublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="classEQueuePrivate.html">EQueuePrivate</a>  </td><td class="markdownTableBodyLeft">A message queue is a FIFO (first in first out) list of messages. Since these messages may be shared across processes, pointer values are not allowed. A message class derived from <a class="el" href="classEMessage.html">EMessage</a> provides utilities to pack and unpack data that can be written to and read from a queue. An application can attach to a public queue by specifying the queue ID when calling the <a class="el" href="classEQueuePublic.html#a66e656a4c8a66cf2c2dd053b50b4208f">init()</a> method.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a>  </td><td class="markdownTableBodyLeft"><a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a>  </td><td class="markdownTableBodyLeft">A thread provides multiple threads of execution within the same program in a shared memory address space. Threads allow for concurrent programming and, on multiple processor/core systems, true parallelism. To send an event message to a public thread from a different process, the application must first create an instance of <a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a> that refers to the same application ID and thread ID that the target thread was initialized with.   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-shared-memory"></a> </p>
<h2><a class="anchor" id="autotoc_md15"></a>
Shared Memory</h2>
<p>Inter process communication through shared memory is a concept where two or more processes can access the common memory and changes to the shared memory made by one process can viewed (and changed) by another process. The <a class="el" href="classESharedMemory.html">ESharedMemory</a> class provides functionality to allocate, access and release a shared memory block. Once created, a pointer to the shared memory can be retrieved using the <a class="el" href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">getDataPtr()</a> method. Concurrent access to the shared memory should be controlled via an instance of <a class="el" href="classEMutexPublic.html">EMutexPublic</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classESharedMemory.html">ESharedMemory</a> sm;</div>
<div class="line">sm.<a class="code" href="classESharedMemory.html#ad231d66f0e4d22240690008d6131cff7">init</a>( <span class="stringliteral">&quot;/tmp/sm1&quot;</span>, 1, 1048576 );</div>
<div class="line"><span class="keywordtype">void</span> *p = sm.<a class="code" href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">getDataPtr</a>();</div>
</div><!-- fragment --><p>This example either creates or attaches to the shared memory identified by the file <code>"/tmp/sm1"</code> and a shared memory ID of 1 and is 1MB in size. The variable <code>p</code> is assigned the first address of the 1MB shared memory block. When <code>sm</code> goes out of scope, the shared memory will be released if no other clients are attached.</p>
<p><a class="anchor" id="feature-overview-threads"></a> </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Threads</h2>
<p><a class="anchor" id="feature-overview-threads-basic-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md17"></a>
Basic Thread</h3>
<p>A basic thread is a thread wrapper that will execute a user provided procedure/function in a separate thread. The basic thread is defined by deriving a class from <a class="el" href="classEThreadBasic.html">EThreadBasic</a> and overloading the <code>threadProc()</code> method. To initialize and start the thread simply call the <code>init(pVoid arg, Dword stackSize = 0)</code> method. Call <a class="el" href="classEThreadBasic.html#a8c5765e549d250fcc912b41932dc7ff5">join()</a> to wait for the thread to exit. Other useful <a class="el" href="classEThreadBasic.html">EThreadBasic</a> methods include <a class="el" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">sleep(Int milliseconds)</a> and <a class="el" href="classEThreadBasic.html#a36312dfda1c19fc7f40bd82c3f9e4550">yield()</a>.</p>
<p>In this example, a basic thread is defined in the class <code>EThreadBasicTest</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EThreadBasicTest : <span class="keyword">public</span> <a class="code" href="classEThreadBasic.html">EThreadBasic</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   EThreadBasicTest() : m_timetoquit(false) {}</div>
<div class="line"> </div>
<div class="line">   Dword <a class="code" href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">threadProc</a>(Void *arg) {</div>
<div class="line">      <span class="keywordflow">while</span> (!m_timetoquit) {</div>
<div class="line">         cout &lt;&lt; <span class="stringliteral">&quot;Inside the thread [&quot;</span> &lt;&lt; (cpStr)arg &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; endl;</div>
<div class="line">         <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">sleep</a>(1000);</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Exiting EThreadTest::threadProc()&quot;</span> &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   Void setTimeToQuit() {</div>
<div class="line">      m_timetoquit = <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">bool</span> m_timetoquit;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Void EThreadBasic_test() {</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Start&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">   EThreadBasicTest t;</div>
<div class="line"> </div>
<div class="line">   t.init((Void *)<span class="stringliteral">&quot;this is the thread argument&quot;</span>);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before 5 second sleep sleep&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.sleep(5000);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before setTimeToQuit()&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.setTimeToQuit();</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before join&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.join();</div>
<div class="line"> </div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Complete&quot;</span> &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-threads-event-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md18"></a>
Event Thread</h3>
<p>An event thread responds to event messages sent to the thread by invoking the associated message handler method defined in the class. The event message queue for the thread can either be allocated from the heap, a private event thread, or allocated from shared memory, a public event thread. <a class="el" href="classEThreadEvent.html">EThreadEvent</a> is a templated class that takes two parameters 1) the queue class and 2) the event message class to be used for this thread.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-queue"></a> </p>
<h4><a class="anchor" id="autotoc_md19"></a>
Event Queues</h4>
<p>The two event queue template classes, <a class="el" href="classEThreadQueuePublic.html">EThreadQueuePublic</a> and <a class="el" href="classEThreadQueuePrivate.html">EThreadQueuePrivate</a>, each take a template parameter of an event message class. <a class="el" href="classEThreadQueuePublic.html">EThreadQueuePublic</a> creates the event queue in shared memory allowing thread events to be posted from any process, and <a class="el" href="classEThreadQueuePrivate.html">EThreadQueuePrivate</a> creates the event queue on the heap which limits thread events to only be posted from within the same process.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-message"></a> </p>
<h4><a class="anchor" id="autotoc_md20"></a>
Event Message</h4>
<p>The event message object will be passed to the event handler method defined in the derived thread class. The basic functionality of an event message is encapsulated in the <a class="el" href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a> and contains the event message ID and a timer that measures the amount of time an event message spends in the event queue. Additionally, the event message must contain a void pointer. This is needed to distribute timer events. The standard implementation of an event message is contained in <a class="el" href="classEThreadMessage.html">EThreadMessage</a>. The event data for this class is a union defined as follows: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span>  <span class="keyword">union </span>{</div>
<div class="line">    pVoid voidptr;</div>
<div class="line">    LongLong int64;</div>
<div class="line">    Long int32[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(Long)];</div>
<div class="line">    Short int16[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(Short)];</div>
<div class="line">    Char int8[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(Char)];</div>
<div class="line">    ULongLong uint64;</div>
<div class="line">    ULong uint32[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(ULong)];</div>
<div class="line">    UShort uint16[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(UShort)];</div>
<div class="line">    UChar uint8[<span class="keyword">sizeof</span>(pVoid) /  <span class="keyword">sizeof</span>(UChar)];</div>
<div class="line">} DataUnion;</div>
</div><!-- fragment --><p> <a class="el" href="classEThreadMessage.html">EThreadMessage</a> has several overloaded constructors that can populate various elements of the union. Additionally, one constructor takes a reference to an instance of <a class="el" href="classEThreadEventMessageData.html">EThreadEventMessageData</a> which provides the developer with the ability to initialize any combination of union members.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-message-custom"></a> </p>
<h4><a class="anchor" id="autotoc_md21"></a>
Custom Event Message</h4>
<p>A custom or user-defined event message class can be used for a thread by developing the following classes:</p>
<ol type="1">
<li>Define the data that will be contained in the custom event message by deriving a class from <a class="el" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>. <div class="fragment"><div class="line"><span class="keyword">class  </span>MyCustomEventData : <span class="keyword">public</span>  <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyCustomEventData() : <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>(), m_voidptr(), m_print(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>), m_val() {}</div>
<div class="line">    MyCustomEventData(UInt  msgid) : <a class="code" href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a>(msgid), m_voidptr(), m_val() {}</div>
<div class="line"> </div>
<div class="line">    pVoid  <a class="code" href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">getVoidPtr</a>() { <span class="keywordflow">return</span> m_voidptr; }</div>
<div class="line">    Void  <a class="code" href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">setVoidPtr</a>(pVoid  p) { m_voidptr = p; }</div>
<div class="line"> </div>
<div class="line">    Void  setValue(Int  idx, Int  val) { <span class="keywordflow">if</span> (idx&gt;=0  &amp;&amp; idx&lt;4) m_val[idx] = val; }</div>
<div class="line">    Int  getValue(Int  idx) { <span class="keywordflow">if</span> (idx&gt;=0  &amp;&amp; idx&lt;4) <span class="keywordflow">return</span>  m_val[idx]; <span class="keywordflow">return</span>  -1; }</div>
<div class="line"> </div>
<div class="line">    Void  setPrint(Bool  print) { m_print = print; }</div>
<div class="line">    Bool  getPrint() { <span class="keywordflow">return</span> m_print; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    pVoid m_voidptr;</div>
<div class="line">    Bool m_print;</div>
<div class="line">    Int m_val[4];</div>
<div class="line">};</div>
</div><!-- fragment --> <b>NOTE:</b> The custom event data object must provide access to a void pointer and provide definitions for <a class="el" href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">EThreadEventMessageDataBase::getVoidPtr()</a> and <a class="el" href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">EThreadEventMessageDataBase::setVoidPtr()</a>.</li>
<li>Define the custom event message class by deriving a class from <a class="el" href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a> utilizing the custom event data class previously defined. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadEventMessageBase.html">EThreadEventMessageBase&lt;MyCustomEventData&gt;</a> MyCustomEvent;</div>
</div><!-- fragment --></li>
<li>Define the custom event queue class utilizing the previously defined custom event message class. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadQueuePublic.html">EThreadQueuePublic&lt;MyCustomEvent&gt;</a> MyCustomEventPublicQueue;</div>
</div><!-- fragment --></li>
<li>Finally, define the custom thread class that will utilize the previously defined custom event queue class. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classEThreadEvent.html">EThreadEvent&lt;MyCustomEventPublicQueue, MyCustomEvent&gt;</a> MyCustomThreadEventPublic;</div>
</div><!-- fragment --></li>
<li>Derive a thread class from the newly defined custom thread class and define the message handlers using the custom event message class. <div class="fragment"><div class="line"><span class="keyword">class  </span>MyCustomThread : <span class="keyword">public</span>  MyCustomThreadEventPublic</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    Void  myhandler(MyCustomEvent  &amp;msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg.data().getPrint())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt;  <span class="stringliteral">&quot;MyCustomThread::myhandler() -&quot;</span></div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; event=&quot;</span>  &lt;&lt;  msg.data().getMessageId()</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_voidptr=&quot;</span>  &lt;&lt;  msg.data().getVoidPtr()</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_print=&quot;</span>  &lt;&lt; (msg.data().getPrint()?<span class="stringliteral">&quot;TRUE&quot;</span>:<span class="stringliteral">&quot;FALSE&quot;</span>)</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_val[0]=&quot;</span>  &lt;&lt;  msg.data().getValue(0)</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_val[1]=&quot;</span>  &lt;&lt;  msg.data().getValue(1)</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_val[2]=&quot;</span>  &lt;&lt;  msg.data().getValue(2)</div>
<div class="line">                &lt;&lt;  <span class="stringliteral">&quot; m_val[3]=&quot;</span>  &lt;&lt;  msg.data().getValue(3)</div>
<div class="line">                &lt;&lt;  std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ol>
<p><a class="anchor" id="feature-overview-threads-event-thread-event-processing"></a> </p>
<h4><a class="anchor" id="autotoc_md22"></a>
Event Processing</h4>
<p><b>Standard Events and Callbacks</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM_INIT  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit()</a>  </td><td class="markdownTableBodyLeft">The EM_INIT message will is posted to the thread when the thread is started. Normally, this is the first message that will be processed. However, for a public thread, it is possible that the process sending thread events could start before the thread is started which would result in the EM_INIT event to not be the first event processed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM_QUIT  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit()</a>  </td><td class="markdownTableBodyLeft">This event is posted to the thread when the <a class="el" href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">quit()</a> method is invoked on the thread. This will be the last event processed by the thread before the thread exits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM_SUSPEND  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#a8e005870b9f594bfea391b03030d38bd">onSuspend()</a>  </td><td class="markdownTableBodyLeft">This event is posted to a thread when the <a class="el" href="classEThreadEvent.html#a951ebb6aa1c4f060e45272d1aeb80562">suspend()</a> method has been invoked. This will be the last event processed prior to the thread suspending event processing.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM_TIMER  </td><td class="markdownTableBodyNone"><a class="el" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer()</a>  </td><td class="markdownTableBodyLeft">The EM_TIMER event will be posted to a thread when a timer associated with the thread expires. A pointer to the timer object that has expired is included as an argument to the <a class="el" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer()</a> method.   </td></tr>
</table>
<p>User defined events ID's start with EM_USER. The association between the event ID and the event handler is defined in the message map. The following macros are used for declaring the message map and creating the association between the event ID and the event handler.</p>
<p><b>Message Map Macros</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro  </th><th class="markdownTableHeadLeft">Arguments  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">None  </td><td class="markdownTableBodyLeft">This macro must appear in the class definition. It's inclusion will create the necessary definitions within the class to support the message map definition and usage.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">The class<br  />
The base class  </td><td class="markdownTableBodyLeft">This macro starts the definition of the message map. The first argument is the current class name and the second argument is base class of the current class.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE()</a>  </td><td class="markdownTableBodyLeft">Event ID<br  />
Event handler method  </td><td class="markdownTableBodyLeft">Each user event that is to be handled by the class must have an entry in the message map that establishes the association between the event ID and the event handler method. The event handler method name must be fully qualified.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP()</a>  </td><td class="markdownTableBodyLeft">None  </td><td class="markdownTableBodyLeft">This macro closes the message map declaration.   </td></tr>
</table>
<p>The message map declaration within the class should be performed as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#define MYEVENT (EM_USER + 1)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyThread : <span class="keyword">public</span> <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    Void myhandler(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a>()</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>The definition of the message map should happen in code as follows: </p><div class="fragment"><div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(MyThread, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(MYEVENT, MyThread::myhandler)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p><a class="anchor" id="feature-overview-threads-event-thread-inheritance"></a> </p>
<h4><a class="anchor" id="autotoc_md23"></a>
Event Dispatching and Inheritance</h4>
<p>When an event is posted to the thread's event queue, the thread will dequeue the event message and call the event handler associated with the event ID. This process is referred to as event dispatching. The association between the event ID and the event handler is defined in the message map.</p>
<div class="fragment"><div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTest, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTest::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTest::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p> In this example, <code>EThreadTest</code> is derived from <a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a> and there are two event handlers defined in <code>EThreadTest</code>: <code>userFunc1()</code> and <code>userFunc2()</code>. According to the message map, when event <code>EM_USER1</code> is received, the dispatcher will call <code>userFunc1()</code> and when <code>EM_USER2</code> is received, the dispatcher will call <code>userFunc2()</code>.</p>
<p>The event dispatcher searches the message map looking for the event ID. If the event ID is not found, the dispatcher will then search the parent class which is the second parameter in the <code>BEGIN_MESSAGE_MAP</code> macro. This process will continue until a handler is identified or there are no more base classes to evaluate. In this case, the <a class="el" href="classEThreadEvent.html">defMessageHandler()</a> will be called to process the message. </p><div class="fragment"><div class="line"><span class="keyword">class </span>EThreadTestParent : <a class="code" href="classEThreadEvent.html">EThreadPrivate</a> {</div>
<div class="line">    ....</div>
<div class="line">    Void userFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    Void userFunc2(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestParent, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestParent::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTestParent::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line"> </div>
<div class="line">class EThreadTestChild : public EThreadTestParent {</div>
<div class="line">    ....</div>
<div class="line">    Void childUserFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestChild, EThreadTestParent)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestChild::childUserFunc1)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p> The above example demonstrates the inheritance behavior of the event dispatcher. When an instance of <code>EThreadTestParent</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestParent::userFunc1()</code> will be called to process the event. Similarly, when an instance of <code>EThreadTestChild</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestChild::childUserFunc1()</code> will be called. Finally, when <code>EM_USER2</code> is sent to the instance of <code>EThreadTestChild</code>, the event dispatcher will call <code>EThreadTestParent::userFunc2()</code> to process the event message since there isn't an event handler defined in <code>EThreadTestChild</code> to process <code>EM_USER2</code>.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-timers"></a> </p>
<h4><a class="anchor" id="autotoc_md24"></a>
Timers</h4>
<p><a class="el" href="classEThreadEvent.html">EThreadEvent</a> supports two types of timers: a periodic timer and a one-shot timer. A periodic timer will emit a timer expiration event X number of milliseconds as defined by the interval of the timer. These timer expiration events will continue until the timer is stopped or destroyed. By contrast, a one-shot timer will generate a single timer expiration event after the duration specified by the timer's interval value.</p>
<p>Both timer types, periodic and one-shot, are represented by the <a class="el" href="classEThreadEventTimer.html">EThreadEventTimer</a> class.</p>
<p><b>Periodic Timer Setup</b> </p><div class="fragment"><div class="line"><a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> mytimer;</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">setInterval</a>(1000);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">setOneShot</a>(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">mythread.initTimer(mytimer);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">start</a>();</div>
</div><!-- fragment --><p> This example will create a periodic timer that will expire once every 1,000 milliseconds (1 second). Each time the timer expires, the onTimer() method of the <code>mythread</code> object will be invoked.</p>
<p><b>One-Shot Timer Setup</b> </p><div class="fragment"><div class="line"><a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> mytimer;</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">setInterval</a>(1000);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">setOneShot</a>(<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>);</div>
<div class="line">mythread.initTimer(mytimer);</div>
<div class="line">mytimer.<a class="code" href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">start</a>();</div>
</div><!-- fragment --><p> This example will create a one-shot timer that will expire after 1,000 milliseconds (1 second). The timer can be re-used by calling <code>mytimer.start()</code>.</p>
<p>Both periodic and one-shot timers can be stopped by calling the timer <code>stop()</code> method.</p>
<p><a class="anchor" id="feature-overview-threads-event-thread-example"></a> </p>
<h4><a class="anchor" id="autotoc_md25"></a>
Example</h4>
<p>In this example, the has 2 timers that are associated with it, the periodic timer and the overall timer. When the periodic timer expires, for example every 1 second, the onTimer() method will be called which will in turn send the MYEVENT event to the thread which will in turn invoke the myhandler() thread event handler method. When the overall timer expires, for example after 10 seconds, the onTimer() method will call quit() which will trigger the onQuit method to be invoked and the thead will exit. Both timers are initialized and started when the thread is started and invokes the onInit() method. The threadExample() function instantiates the thread and waits for the thread to exit.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define  MYEVENT (EM_USER + 1)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class  </span>MyThread : <span class="keyword">public</span>  <a class="code" href="classEThreadEvent.html">EThreadPrivate</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyThread(Long  periodic_ms, Long  overall_ms)</div>
<div class="line">    {</div>
<div class="line">        m_periodic_ms = periodic_ms;</div>
<div class="line">        m_overall_ms = overall_ms;</div>
<div class="line">        m_count =  0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">onInit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; invoked&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; initializing periodic timer(&quot;</span>  &lt;&lt;  m_periodic.getId() &lt;&lt;  <span class="stringliteral">&quot;) to &quot;</span>  &lt;&lt; m_periodic_ms &lt;&lt;  <span class="stringliteral">&quot;ms&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">        m_periodic.setInterval(m_periodic_ms);</div>
<div class="line">        m_periodic.setOneShot(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">        <a class="code" href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">initTimer</a>(m_periodic);</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; initializing overall timer(&quot;</span>  &lt;&lt;  m_overall.getId() &lt;&lt;  <span class="stringliteral">&quot;) to &quot;</span>  &lt;&lt; m_overall_ms &lt;&lt;  <span class="stringliteral">&quot;ms&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">        m_overall.setInterval(m_overall_ms);</div>
<div class="line">        m_overall.setOneShot(<a class="code" href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>);</div>
<div class="line">        <a class="code" href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">initTimer</a>(m_overall);</div>
<div class="line">          </div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; starting periodic timer&quot;</span>  &lt;&lt;  <span class="stringliteral">&quot;ms&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">        m_periodic.start();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; starting overall timer&quot;</span>  &lt;&lt;  <span class="stringliteral">&quot;ms&quot;</span>  &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">        m_overall.start();</div>
<div class="line">          </div>
<div class="line">        m_count =  0;</div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">onQuit</a>()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; invoked - count=&quot;</span>  &lt;&lt; m_count &lt;&lt;  std::endl &lt;&lt;  std::flush;</div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">    Void  <a class="code" href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">onTimer</a>(<a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a>  *ptimer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (ptimer-&gt;<a class="code" href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">getId</a>() ==  m_periodic.getId())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classEThreadEvent.html#adbdfea9c7c873363a05241dd166fa65b">sendMessage</a>(MYEVENT);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span>  <span class="keywordflow">if</span> (ptimer-&gt;<a class="code" href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">getId</a>() ==  m_overall.getId())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">quit</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Void  myhandler(<a class="code" href="classEThreadMessage.html">EThreadMessage</a>  &amp;msg)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt;  <span class="stringliteral">&quot; invoked&quot;</span>  &lt;&lt;  std::endl;</div>
<div class="line">        m_count++;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a>()</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    MyThread();</div>
<div class="line">    Long m_periodic_ms;</div>
<div class="line">    Long m_overall_ms;</div>
<div class="line">    Int m_count;</div>
<div class="line">    <a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> m_periodic;</div>
<div class="line">    <a class="code" href="classEThreadEventTimer.html">EThreadEventTimer</a> m_overall;</div>
<div class="line">};</div>
<div class="line">  </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(MyThread, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(MYEVENT, MyThread::myhandler)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line"> </div>
<div class="line">Void  threadExample()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> Long periodic_ms =  1000;</div>
<div class="line">    <span class="keyword">static</span> Long overall_ms =  10000;</div>
<div class="line">    Char buffer[128];</div>
<div class="line">      </div>
<div class="line">    cout &lt;&lt;  <span class="stringliteral">&quot;Enter the periodic timer duration in milliseconds [&quot;</span>  &lt;&lt; periodic_ms &lt;&lt;  <span class="stringliteral">&quot;]: &quot;</span>;</div>
<div class="line">    cin.getline(buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line">    periodic_ms =  *buffer ?  std::stol(buffer) : periodic_ms;</div>
<div class="line">      </div>
<div class="line">    cout &lt;&lt;  <span class="stringliteral">&quot;Enter the overall timer duration in milliseconds [&quot;</span>  &lt;&lt; overall_ms &lt;&lt;  <span class="stringliteral">&quot;]: &quot;</span>;</div>
<div class="line">    cin.getline(buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line">    overall_ms =  *buffer ?  std::stol(buffer) : overall_ms;</div>
<div class="line">      </div>
<div class="line">    MyThread t(periodic_ms, overall_ms);</div>
<div class="line">      </div>
<div class="line">    std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; Starting thread example&quot;</span>  &lt;&lt;  std::endl;</div>
<div class="line">    t.init(1,1,NULL);</div>
<div class="line">    t.join();</div>
<div class="line">    std::cout &lt;&lt;  <a class="code" href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a>().<a class="code" href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">Format</a>(<span class="stringliteral">&quot;%i&quot;</span>,<a class="code" href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>) &lt;&lt;  <span class="stringliteral">&quot; Thread example complete&quot;</span>  &lt;&lt;  std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>An event thread is derived from either <a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a> or <a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a>. An event based thread maintains an internal event message queue. Event messages are added to the event queue using one of the sendMessage() methods. sendMessage() can be called from any thread. Internally, the event thread blocks waiting for an event message to be added to the event message queue. When an event message appears in the event queue, the message is dequeued and the appropriate handler is identified and executed. The association between event ID's and handlers is defined in a message map. </p><div class="fragment"><div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTest, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTest::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTest::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p> In this example, <code>EThreadTest</code> is derived from <a class="el" href="etevent_8h.html#a8ec0f12a7073f7d1375468685b80b8dd">EThreadPrivate</a> and there are two event handlers defined in <code>EThreadTest</code>: <code>userFunc1()</code> and <code>userFunc2()</code>. According to the message map, when event <code>EM_USER1</code> is received, the dispatcher will call <code>userFunc1()</code> and when <code>EM_USER2</code> is received, the dispatcher will call <code>userFunc2()</code>.</p>
<p>The event dispatcher searches the message map looking for the event ID. If the event ID is not found, the dispatcher will then search the parent class which is the second parameter in the <code>BEGIN_MESSAGE_MAP</code> macro. This process will continue until a handler is identified or there are no more base classes to evaluate. In this case, the defMessageHandler() will be called to process the message. </p><div class="fragment"><div class="line"><span class="keyword">class </span>EThreadTestParent : <a class="code" href="classEThreadEvent.html">EThreadPrivate</a> {</div>
<div class="line">    ....</div>
<div class="line">    Void userFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    Void userFunc2(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestParent, <a class="code" href="classEThreadEvent.html">EThreadPrivate</a>)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestParent::userFunc1)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER2, EThreadTestParent::userFunc2)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
<div class="line"> </div>
<div class="line">class EThreadTestChild : public EThreadTestParent {</div>
<div class="line">    ....</div>
<div class="line">    Void childUserFunc1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a>(EThreadTestChild, EThreadTestParent)</div>
<div class="line">    <a class="code" href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a>(EM_USER1, EThreadTestChild::childUserFunc1)</div>
<div class="line"><a class="code" href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a>()</div>
</div><!-- fragment --><p> This example demonstrates the inheritance behavior of the event dispatcher. When an instance of <code>EThreadTestParent</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestParent::userFunc1()</code> will be called to process the event. Similarly, when an instance of <code>EThreadTestChild</code> is created and <code>EM_USER1</code> is sent to it, <code>EThreadTestChild::childUserFunc1()</code> will be called. Finally, when <code>EM_USER2</code> is sent to the instance of <code>EThreadTestChild</code>, the event dispatcher will call <code>EThreadTestParent::userFunc2()</code> to process the event message since there isn't an event handler defined in <code>EThreadTestChild</code> to process <code>EM_USER2</code>.</p>
<p>In addition to custom event message handlers, the dispatcher also identifies special events including <code>EM_INIT</code>, <code>EM_QUIT</code>, <code>EM_SUSPEND</code> and <code>EM_TIMER</code>. When one of these events is identified, the corresponding method will be called (onInit(), onQuit(), onSuspend() and onTimer()).</p>
<h3><a class="anchor" id="autotoc_md26"></a>
Public Event Threads</h3>
<p>The benefit of a public event thread over a private event thread is that thread event messages can be sent from a thread in one process to a thread in another process. This is achieved by storing the event message queue in shared memory. When a process creates an instance of a class derived from EThreadPublic the <a class="el" href="classEThreadEvent.html#abd80672a331041d46982c9c7f873cdc1">init()</a> is called with an application ID and thread ID. These ID's are used to locate the public event message queue in shared memory. If the specified application ID and thread ID do not exist in shared memory when <a class="el" href="classEThreadEvent.html#abd80672a331041d46982c9c7f873cdc1">init()</a> is called, then the thread is created in the current process and the thread's event message queue is created in shared memory. If the application ID and thread ID are found in shared memory, then thread object attaches to the public event queue and no local thread is created.</p>
<p>Here is sample code for the application that will host the public thread. </p><div class="mydiv"> <div class="fragment"><div class="line"><span class="preprocessor">#define EVENT1 (EM_USER + 1)</span></div>
<div class="line"><span class="keyword">class </span>MyThread : <span class="keyword">public</span> <a class="code" href="classEThreadEvent.html">EThreadPublic</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ....</div>
<div class="line">    Void eventHandler1(<a class="code" href="classEThreadMessage.html">EThreadMessage</a> &amp;msg);</div>
<div class="line">    ....</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">....</div>
<div class="line">    MyThread t;</div>
<div class="line">    t.init(<span class="comment">/*application id*/</span> 1, <span class="comment">/*thread id*/</span> 1);</div>
<div class="line">....</div>
</div><!-- fragment --> </div><p>And here is sample code for the application that will send event messages. </p><div class="mydiv"> <div class="fragment"><div class="line"><span class="preprocessor">#define EVENT1 (EM_USER + 1)</span></div>
<div class="line"> </div>
<div class="line">....</div>
<div class="line">    <a class="code" href="classEThreadEvent.html">EThreadPublic</a> t;</div>
<div class="line">    t.<a class="code" href="classEThreadEvent.html#abd80672a331041d46982c9c7f873cdc1">init</a>(<span class="comment">/*application id*/</span> 1, <span class="comment">/*thread id*/</span> 1);</div>
<div class="line">....</div>
<div class="line">    t.<a class="code" href="classEThreadEvent.html#adbdfea9c7c873363a05241dd166fa65b">sendMessage</a>(EVENT1);</div>
<div class="line">....</div>
</div><!-- fragment --> </div><p>You will notice that the thread in the second example is an instance of <a class="el" href="etevent_8h.html#a8954bda7259449b5e33a0c90f00f3e4a">EThreadPublic</a> while the thread in the first example is an instance of <code>MyThread</code>. This is because the thread object in the second example will only be used to send event messages, it will not be processing any events, therefore it doesn't need any event handlers.</p>
<p><em><b>NOTE:</b></em> The order that these two applications are started is very important. The first application to start will host the thread and in this case we would want the code in the first example to be started first.</p>
<p><a class="anchor" id="feature-overview-message-queue"></a> </p>
<h2><a class="anchor" id="autotoc_md27"></a>
Message Queue</h2>
<p><a class="anchor" id="feature-overview-message-queue-pack-unpack"></a> </p>
<h3><a class="anchor" id="autotoc_md28"></a>
Pack/Unpack</h3>
<p><a class="anchor" id="feature-overview-synchronization"></a> </p>
<h2><a class="anchor" id="autotoc_md29"></a>
Synchronization</h2>
<p><a class="anchor" id="feature-overview-synchronization-mutex"></a> </p>
<h3><a class="anchor" id="autotoc_md30"></a>
Mutex</h3>
<p><a class="anchor" id="feature-overview-synchronization-semaphore"></a> </p>
<h3><a class="anchor" id="autotoc_md31"></a>
Semaphore</h3>
<p><a class="anchor" id="feature-overview-synchronization-event"></a> </p>
<h3><a class="anchor" id="autotoc_md32"></a>
Event</h3>
<p><a class="anchor" id="feature-overview-synchronization-read-write-lock"></a> </p>
<h3><a class="anchor" id="autotoc_md33"></a>
Read/Write Lock</h3>
<p><a class="anchor" id="feature-overview-socket-communications"></a> </p>
<h2><a class="anchor" id="autotoc_md34"></a>
Socket Communications</h2>
<p>Asynchronous socket communications is supported by <em><b><a class="el" href="classEpcTools.html" title="The primary class used to initialize/uninitialize EpcTools.">EpcTools</a></b></em> in the <a class="el" href="namespaceESocket.html" title="The namespace for all socket related classes.">ESocket</a> namespace. Currently, support for IPv4 and IPv6 with both TCP and UDP have been implemented. The framework can be enhanced to support additional socket types such as Unix domain socket.</p>
<p><a class="anchor" id="feature-overview-socket-communications-socket-thread"></a> </p>
<h3><a class="anchor" id="autotoc_md35"></a>
Socket Thread</h3>
<p><a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> is derived from EThreadPrivate and has a custom message pump and dispatcher to identify and process socket events for sockets that are registered with the socket thread. The message pump function utilizes <code>select()</code> to detect when a socket can be read from, written to or when an error has occurred. These events are then dispatched to appropriate callback methods depending on the role and state of the socket.</p>
<p>In addition to processing socket events <a class="el" href="classESocket_1_1Thread.html">ESocket::Thread</a> is also capable of processing standard event messages. See <a href="#feature-overview-threads-event-thread">Event Thread</a> for more information.</p>
<p><a class="anchor" id="feature-overview-socket-communications-tcp"></a> </p>
<h3><a class="anchor" id="autotoc_md36"></a>
TCP</h3>
<p>TCP is a streaming connection based protocol. As such, a TCP application will either act as a client (connects to a server) or as a server (accepts connections from clients). The <a class="el" href="namespaceESocket_1_1TCP.html">ESocket::TCP</a> namespace contains the class definitions used by the client and server applications.</p>
<p>A server application listens for incoming connections using a class derived from <a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Listener</a>. When the listener detects an incoming connection, the <a class="el" href="classESocket_1_1TCP_1_1Listener.html#ac2910b7d5739e9291784cc3af4bfab01">TCP::Listener::createSocket()</a> will be called to create an instance of a class derived from <a class="el" href="classESocket_1_1TCP_1_1Talker.html">TCP::Talker</a> that will be used to received data from and send data to the client.</p>
<p>Conversely, a client application initiates a connection to a server by calling the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#ad4be48c44bed5afc09c823c7c53f6a3d">connect()</a> method with the IP address, IPv4 or IPv6, and port of the server. When the connection is complete, the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">onConnect()</a> method of the socket object will be called by the dispatcher indicating that the connection is up and communication can proceed.</p>
<p><b><a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Listener</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">TCP::Talker::onConnect</a>  </td><td class="markdownTableBodyLeft">A listening socket will indicate that it can be read from when a new client connects. The internals will create a new <a class="el" href="classESocket_1_1TCP_1_1Talker.html">TCP::Talker</a> object to handle the new connection by calling the <a class="el" href="classESocket_1_1TCP_1_1Listener.html#ac2910b7d5739e9291784cc3af4bfab01">TCP::Listener::createSocket()</a> method. Once the talking object has been created, the dispatcher will then call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#a1f2208e942a66964cc5be4ca1e172aa6">TCP::Talker::onConnect()</a> method to start communication with the new client.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">This event is not applicable to a listening socket.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Listener.html#a1477b6dd6c8da334612db807d9c22f75">TCP::Listener::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket while listening for new connections.   </td></tr>
</table>
<p><b><a class="el" href="classESocket_1_1TCP_1_1Listener.html">TCP::Talker</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">TCP::Talker::onReceive</a><br  />
<a class="el" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">TCP::Talker::onClose</a>  </td><td class="markdownTableBodyLeft">When a talking socket indicates that it can be read, the framework calls <code>recv()</code> to read any pending data. If zero bytes are read, the socket has been closed and the dispatcher will call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#ab3fbfcfbd4fc5378966ad4362779006c">TCP::Talker::onClose()</a> method. If more than zero bytes are read, the data is inserted it into an internal receive buffer and the dispatcher will call the <a class="el" href="classESocket_1_1TCP_1_1Talker.html#aa2ee361ebd7638ae4a2c2a3c1dc44f39">TCP::Talker::onReceive()</a> method allowing the application to process the data that has been read.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">The framework processes the write event by attempting to send any unsent data to the peer. No application interaction is required to process this event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1TCP_1_1Talker.html#ade2186d5cc1b4eef1cbb679e28a34895">TCP::Talker::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket.   </td></tr>
</table>
<p><a class="anchor" id="feature-overview-socket-communications-udp"></a> </p>
<h3><a class="anchor" id="autotoc_md37"></a>
UDP</h3>
<p><b><a class="el" href="classESocket_1_1UDP.html">UDP</a> Events</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Callback Method  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Read  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive</a>  </td><td class="markdownTableBodyLeft">When a UDP socket indicates that it can be read, the framework calls <code>recvfrom()</code> to read any pending data. If more than zero bytes are read, the data is inserted it into an internal receive buffer and the dispatcher will call the <a class="el" href="classESocket_1_1UDP.html#a6dfcc6372f4e8e9acbb2e4685b147d12">UDP::onReceive()</a> method allowing the application to process the data that has been read.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Write  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyLeft">The framework processes the write event by sending any unsent messages to the destination. No application interaction is required to process this event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error  </td><td class="markdownTableBodyNone"><a class="el" href="classESocket_1_1UDP.html#a7853433bb2daa353e88263ac62d9e04f">UDP::onError</a>  </td><td class="markdownTableBodyLeft">Indicates that an error has occurred on the socket.   </td></tr>
</table>
<pre class="fragment">-# [Logging](#feature-overview-logging)
-# [DNS](#feature-overview-dns)
    -# [Cache](#feature-overview-dns-cache)
    -# [EPC Node Discovery](#feature-overview-dns-epc-node-discovery)
    -# [Diameter S-NAPTR](#feature-overview-dns-diameter-s-naptr)
-# [REST Server](#feature-overview-rest-server)
-# [freeDiameter](#feature-overview-freediameter)
-# [Interface Statistics](#feature-overview-statistics)
-# [Timer Pool](#feature-overview-timer-pool)
-# [Miscellaneous](#feature-overview-miscellaneous)
    -# [String](#feature-overview-miscellaneous-string)
    -# [Utilities](#feature-overview-miscellaneous-utilities)
    -# [Time](#feature-overview-miscellaneous-time)
    -# [Timer](#feature-overview-miscellaneous-timer)
    -# [Path](#feature-overview-miscellaneous-path)
    -# [Directory](#feature-overview-miscellaneous-directory)
    -# [Error](#feature-overview-miscellaneous-error)
    -# [Hash](#feature-overview-miscellaneous-hash)
    -# [BZip2](#feature-overview-miscellaneous-bzip2)
    -# [Circular Buffer](#feature-overview-miscellaneous-circular-buffer)
</pre><p><a class="anchor" id="feature-overview-logging"></a> </p>
<h2><a class="anchor" id="autotoc_md38"></a>
Logging</h2>
<p><a class="anchor" id="feature-overview-dns"></a> </p>
<h2><a class="anchor" id="autotoc_md39"></a>
DNS</h2>
<p><a class="anchor" id="feature-overview-dns-cache"></a> </p>
<h3><a class="anchor" id="autotoc_md40"></a>
DNS Cache</h3>
<p><a class="anchor" id="feature-overview-dns-epc-node-discovery"></a> </p>
<h3><a class="anchor" id="autotoc_md41"></a>
EPC Node Discovery</h3>
<p><a class="anchor" id="feature-overview-dns-diameter"></a> </p>
<h3><a class="anchor" id="autotoc_md42"></a>
Diameter S-NAPTR</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h2><a class="anchor" id="autotoc_md43"></a>
REST Server</h2>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h2><a class="anchor" id="autotoc_md44"></a>
freeDiameter</h2>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h2><a class="anchor" id="autotoc_md45"></a>
Interface Statistics</h2>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h2><a class="anchor" id="autotoc_md46"></a>
Timer Pool</h2>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h2><a class="anchor" id="autotoc_md47"></a>
Miscellaneous</h2>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md48"></a>
String</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md49"></a>
Utilities</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md50"></a>
Time</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md51"></a>
Timer</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md52"></a>
Path</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md53"></a>
Directory</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md54"></a>
Error</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md55"></a>
Hash</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md56"></a>
BZip2</h3>
<p><a class="anchor" id="feature-overview-"></a> </p>
<h3><a class="anchor" id="autotoc_md57"></a>
Circular Buffer</h3>
<h3><a class="anchor" id="autotoc_md58"></a>
Socket Thread</h3>
<p>A socket thread is derived from an event thread. The socket thread has a custom message pump and dispatcher to identify and process any socket event for sockets that are registered with the current socket thread. The message pump function utilizes <code>select()</code> to detect the various events associated with the registered sockets.with the addition that it can detect and process socket events. This is achieved with a specialized message pump that also capable of </p><pre class="fragment">- Event Based Thread
    - Each thread maintains an internal event queue
    - User defined event handlers
</pre><ul>
<li>Thread based timers</li>
<li>Private thread - can only be sent events from threads within the same process</li>
<li>Public thread - can be sent events from the same or different processes</li>
</ul>
<p>Asynchronous IP communications</p><ul>
<li>TCP with both "listener" and "talker" classes</li>
<li>UDP support</li>
<li>IPv4 and IPv6 address support</li>
<li>Socket events are processed from within an event based socket thread</li>
</ul>
<p>Cached <a class="el" href="namespaceDNS.html">DNS</a> client</p><ul>
<li>Supports multiple <a class="el" href="namespaceDNS.html">DNS</a> caches, with each <a class="el" href="namespaceDNS.html">DNS</a> cache being associated with one or more named servers</li>
<li>Support for 3GPP Domain Name System Procedures as defined in TS 29.303</li>
<li>Support for Diameter <a class="el" href="namespaceDNS.html">DNS</a> usage as defined in RFC 6408</li>
<li>Automated refresh of the cache</li>
<li>"Priming" the cache at startup based on previous usage</li>
</ul>
<p>Configuration</p><ul>
<li>Command line options<ul>
<li>Named options that require an additional typed argument</li>
<li>Named options with out additional arguments (boolean)</li>
<li>Positional arguments</li>
</ul>
</li>
<li>JSON configuration file(s)<ul>
<li>Supports a heirarchial definition of configuration options</li>
<li>Supports array(s) of options</li>
<li>Multiple configuration files can be loaded</li>
</ul>
</li>
</ul>
<p>REST Based Management Interface</p><ul>
<li>A REST based interface for processing external commands<ul>
<li>Extensible user defined handlers (for different commands)</li>
<li>Can support multiple REST servers</li>
</ul>
</li>
</ul>
<p>freeDiameter Support</p><ul>
<li>Supports 1 or more active Diameter applications</li>
<li>Simplified interface for creating messages and adding <a class="el" href="classAVP.html">AVP</a>'s</li>
<li>Extractor classes that eliminate the need to manually extract <a class="el" href="classAVP.html">AVP</a> values</li>
<li>Peer management</li>
</ul>
<p>Synchronization - Mutex using native IPC (pthread) or custom mutex implementation and an optimized Semaphore implementation</p><ul>
<li>Custom queue implementation with message encoding and decoding</li>
<li>Shared Memory configuration and access</li>
<li>Ability to enable or disable public variants of threads, mutexes, semaphores and queues that utilize shared memory</li>
<li>Various utility classes including circular buffer, directory processing, bzip2, time, elapsed timer, string, exception and logging</li>
</ul>
<p><a class="anchor" id="dependencies"></a> </p>
<h1><a class="anchor" id="autotoc_md59"></a>
Dependencies</h1>
<ul>
<li><a href="https://github.com/omec-project/freediameter">freeDiameter</a> - an implementation of the Diameter protocol</li>
<li><a href="http://rapidjson.org">RapidJSON</a> - a JSON parser and generator for C++</li>
<li><a href="https://github.com/gabime/spdlog">spdlog</a> - very fast, header-only/compiled, C++ logging library</li>
<li><a href="http://pistache.io/">pistache</a> - an elegant C++ REST framework</li>
<li><a href="https://www.sourceware.org/bzip2/">bzip2</a> - a freely available, patent free (see below), high-quality data compressor</li>
</ul>
<p><a class="anchor" id="installation"></a> </p>
<h1><a class="anchor" id="autotoc_md60"></a>
Installation</h1>
<p>Clone the project, install the dependencies (via configure), build the static library and install. </p><div class="fragment"><div class="line">$ sudo apt-get update</div>
<div class="line">$ sudo apt-get install mercurial cmake make gcc g++ bison flex libsctp-dev libgnutls-dev libgcrypt-dev libidn11-dev m4 automake</div>
<div class="line">$ git clone https://github.com/brianwaters3/FoundationTools.git epctools</div>
<div class="line">$ cd epctools</div>
<div class="line">$ git checkout sprint</div>
<div class="line">$ ./configure</div>
<div class="line">$ make</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Threading</h2>
<h3><a class="anchor" id="autotoc_md62"></a>
Basic Thread</h3>
<p>To create a basic thread, an object must be derived from <code><a class="el" href="classEThreadBasic.html" title="An abstract class that represents contains the threadProc() that will be run in a separate thread.">EThreadBasic</a></code> overriding the <code><a class="el" href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec" title="Function that will be called in a separate thread.">EThreadBasic::threadProc()</a></code> method which represents the code that will be executed in a separate thread. To initialize and start the thread simply call the <code>Void init(pVoid arg, Dword stackSize = 0)</code> method. Call <code>Void join()</code> to wait for the thread to exit. Other useful <code><a class="el" href="classEThreadBasic.html" title="An abstract class that represents contains the threadProc() that will be run in a separate thread.">EThreadBasic</a></code> methods include <code>static Void sleep(Int milliseconds)</code> and <code>static Void yield()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EThreadBasicTest : <span class="keyword">public</span> <a class="code" href="classEThreadBasic.html">EThreadBasic</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   EThreadBasicTest() : m_timetoquit(false) {}</div>
<div class="line"> </div>
<div class="line">   Dword <a class="code" href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">threadProc</a>(Void *arg) {</div>
<div class="line">      <span class="keywordflow">while</span> (!m_timetoquit) {</div>
<div class="line">         cout &lt;&lt; <span class="stringliteral">&quot;Inside the thread [&quot;</span> &lt;&lt; (cpStr)arg &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; endl;</div>
<div class="line">         <a class="code" href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">sleep</a>(1000);</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Exiting EThreadTest::threadProc()&quot;</span> &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   Void setTimeToQuit() {</div>
<div class="line">      m_timetoquit = <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">bool</span> m_timetoquit;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Void EThreadBasic_test() {</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Start&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">   EThreadBasicTest t;</div>
<div class="line"> </div>
<div class="line">   t.init((Void *)<span class="stringliteral">&quot;this is the thread argument&quot;</span>);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before 5 second sleep sleep&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.sleep(5000);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before setTimeToQuit()&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.setTimeToQuit();</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;before join&quot;</span> &lt;&lt; endl;</div>
<div class="line">   t.join();</div>
<div class="line"> </div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;EThread_test() Complete&quot;</span> &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md63"></a>
Event Thread</h3>
<h3><a class="anchor" id="autotoc_md64"></a>
Socket Thread (TCP)</h3>
<h2><a class="anchor" id="autotoc_md65"></a>
Synchronization</h2>
<h3><a class="anchor" id="autotoc_md66"></a>
Mutex</h3>
<h3><a class="anchor" id="autotoc_md67"></a>
Semaphore</h3>
<h2><a class="anchor" id="autotoc_md68"></a>
Queue</h2>
<h3><a class="anchor" id="autotoc_md69"></a>
Configuration</h3>
<h3><a class="anchor" id="autotoc_md70"></a>
Encode/Decode</h3>
<h2><a class="anchor" id="autotoc_md71"></a>
Shared Memory</h2>
<h2><a class="anchor" id="autotoc_md72"></a>
Configuration</h2>
<h2><a class="anchor" id="autotoc_md73"></a>
Exceptions</h2>
<h2><a class="anchor" id="autotoc_md74"></a>
Logger</h2>
<h3><a class="anchor" id="autotoc_md75"></a>
Tech</h3>
<p>Dillinger uses a number of open source projects to work properly:</p>
<ul>
<li><a href="http://angularjs.org&gt;">AngularJS</a> - HTML enhanced for web apps!</li>
<li><a href="http://ace.ajax.org&gt;">Ace Editor</a> - awesome web-based text editor</li>
<li><a href="https://github.com/markdown-it/markdown-it&gt;">markdown-it</a> - Markdown parser done right. Fast and easy to extend.</li>
<li><a href="http://twitter.github.com/bootstrap/&gt;">Twitter Bootstrap</a> - great UI boilerplate for modern web apps</li>
<li><a href="http://nodejs.org&gt;">node.js</a> - evented I/O for the backend</li>
<li><a href="http://expressjs.com&gt;">Express</a> - fast node.js network app framework <a href="http://twitter.com/tjholowaychuk&gt;">@tjholowaychuk</a></li>
<li><a href="http://gulpjs.com&gt;">Gulp</a> - the streaming build system</li>
<li><a href="http://breakdance.io">Breakdance</a> - HTML to Markdown converter</li>
<li><a href="http://jquery.com&gt;">jQuery</a> - duh</li>
</ul>
<p>And of course Dillinger itself is open source with a <a href="https://github.com/joemccann/dillinger&gt;">public repository</a> on GitHub.</p>
<h3><a class="anchor" id="autotoc_md76"></a>
Installation</h3>
<p>Dillinger requires <a href="https://nodejs.org/">Node.js</a> v4+ to run.</p>
<p>Install the dependencies and devDependencies and start the server.</p>
<div class="fragment"><div class="line">$ git clone https://github.com/brianwaters3/FoundationTools.git epctools</div>
<div class="line">$ cd epctools</div>
<div class="line">$ ./configure</div>
</div><!-- fragment --><p>For production environments...</p>
<div class="fragment"><div class="line">$ npm install --production</div>
<div class="line">$ NODE_ENV=production node app</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md77"></a>
Plugins</h3>
<p>Dillinger is currently extended with the following plugins. Instructions on how to use them in your own application are linked below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Plugin  </th><th class="markdownTableHeadNone">README   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dropbox  </td><td class="markdownTableBodyNone"><a href="https://github.com/joemccann/dillinger/tree/master/plugins/dropbox/README.md&gt;">plugins/dropbox/README.md</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Github  </td><td class="markdownTableBodyNone"><a href="https://github.com/joemccann/dillinger/tree/master/plugins/github/README.md&gt;">plugins/github/README.md</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Google Drive  </td><td class="markdownTableBodyNone"><a href="https://github.com/joemccann/dillinger/tree/master/plugins/googledrive/README.md&gt;">plugins/googledrive/README.md</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OneDrive  </td><td class="markdownTableBodyNone"><a href="https://github.com/joemccann/dillinger/tree/master/plugins/onedrive/README.md&gt;">plugins/onedrive/README.md</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Medium  </td><td class="markdownTableBodyNone"><a href="https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt;">plugins/medium/README.md</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Google Analytics  </td><td class="markdownTableBodyNone"><a href="https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;">plugins/googleanalytics/README.md</a>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md78"></a>
Development</h3>
<p>Want to contribute? Great!</p>
<p>Dillinger uses Gulp + Webpack for fast developing. Make a change in your file and instantanously see your updates!</p>
<p>Open your favorite Terminal and run these commands.</p>
<p>First Tab: </p><div class="fragment"><div class="line">$ node app</div>
</div><!-- fragment --><p>Second Tab: </p><div class="fragment"><div class="line">$ gulp watch</div>
</div><!-- fragment --><p>(optional) Third: </p><div class="fragment"><div class="line">$ karma test</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md79"></a>
Building for source</h4>
<p>For production release: </p><div class="fragment"><div class="line">$ gulp build --prod</div>
</div><!-- fragment --><p> Generating pre-built zip archives for distribution: </p><div class="fragment"><div class="line">$ gulp build dist --prod</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md80"></a>
Docker</h3>
<p>Dillinger is very easy to install and deploy in a Docker container.</p>
<p>By default, the Docker will expose port 8080, so change this within the Dockerfile if necessary. When ready, simply use the Dockerfile to build the image.</p>
<div class="fragment"><div class="line">cd dillinger</div>
<div class="line">docker build -t joemccann/dillinger:${package.json.version} .</div>
</div><!-- fragment --><p> This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out <code>${package.json.version}</code> with the actual version of Dillinger.</p>
<p>Once done, run the Docker image and map the port to whatever you wish on your host. In this example, we simply map port 8000 of the host to port 8080 of the Docker (or whatever port was exposed in the Dockerfile):</p>
<div class="fragment"><div class="line">docker run -d -p 8000:8080 --restart=&quot;always&quot; &lt;youruser&gt;/dillinger:${package.json.version}</div>
</div><!-- fragment --><p>Verify the deployment by navigating to your server address in your preferred browser.</p>
<div class="fragment"><div class="line">127.0.0.1:8000</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md81"></a>
Kubernetes + Google Cloud</h4>
<p>See <a href="https://github.com/joemccann/dillinger/blob/master/KUBERNETES.md">KUBERNETES.md</a></p>
<h3><a class="anchor" id="autotoc_md82"></a>
Todos</h3>
<ul>
<li>Write MORE Tests</li>
<li>Add Night Mode</li>
</ul>
<h2><a class="anchor" id="autotoc_md83"></a>
License</h2>
<p>MIT</p>
<p><b>Free Software, Hell Yeah!</b></p>
<h1><a class="anchor" id="autotoc_md84"></a>
Welcome to StackEdit!</h1>
<p>Hi! I'm your first Markdown file in <b>StackEdit</b>. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the <b>file explorer</b> on the left corner of the navigation bar.</p>
<h1><a class="anchor" id="autotoc_md85"></a>
Files</h1>
<p>StackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible <b>offline!</b></p>
<h2><a class="anchor" id="autotoc_md86"></a>
Create files and folders</h2>
<p>The file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the <b>New file</b> button in the file explorer. You can also create folders by clicking the <b>New folder</b> button.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
Switch to another file</h2>
<p>All your files and folders are presented as a tree in the file explorer. You can switch from one to another by clicking a file in the tree.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Rename a file</h2>
<p>You can rename the current file by clicking the file name in the navigation bar or by clicking the <b>Rename</b> button in the file explorer.</p>
<h2><a class="anchor" id="autotoc_md89"></a>
Delete a file</h2>
<p>You can delete the current file by clicking the <b>Remove</b> button in the file explorer. The file will be moved into the <b>Trash</b> folder and automatically deleted after 7 days of inactivity.</p>
<h2><a class="anchor" id="autotoc_md90"></a>
Export a file</h2>
<p>You can export the current file by clicking <b>Export to disk</b> in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.</p>
<h1><a class="anchor" id="autotoc_md91"></a>
Synchronization</h1>
<p>Synchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your <b>Google Drive</b>, your <b>Dropbox</b> and your <b>GitHub</b> accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow... The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.</p>
<p>There are two types of synchronization and they can complement each other:</p>
<ul>
<li>The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device. &gt; To start syncing your workspace, just sign in with Google in the menu.</li>
<li>The file synchronization will keep one file of the workspace synced with one or multiple files in <b>Google Drive</b>, <b>Dropbox</b> or <b>GitHub</b>. &gt; Before starting to sync files, you must link an account in the <b>Synchronize</b> sub-menu.</li>
</ul>
<h2><a class="anchor" id="autotoc_md92"></a>
Open a file</h2>
<p>You can open a file from <b>Google Drive</b>, <b>Dropbox</b> or <b>GitHub</b> by opening the <b>Synchronize</b> sub-menu and clicking <b>Open from</b>. Once opened in the workspace, any modification in the file will be automatically synced.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Save a file</h2>
<p>You can save any file of the workspace to <b>Google Drive</b>, <b>Dropbox</b> or <b>GitHub</b> by opening the <b>Synchronize</b> sub-menu and clicking <b>Save on</b>. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.</p>
<h2><a class="anchor" id="autotoc_md94"></a>
Synchronize a file</h2>
<p>Once your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.</p>
<p>If you just have modified your file and you want to force syncing, click the <b>Synchronize now</b> button in the navigation bar.</p>
<blockquote class="doxtable">
<p><b>Note:</b> The <b>Synchronize now</b> button is disabled if you have no file to synchronize. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md95"></a>
Manage file synchronization</h2>
<p>Since one file can be synced with multiple locations, you can list and manage synchronized locations by clicking <b>File synchronization</b> in the <b>Synchronize</b> sub-menu. This allows you to list and remove synchronized locations that are linked to your file.</p>
<h1><a class="anchor" id="autotoc_md96"></a>
Publication</h1>
<p>Publishing in StackEdit makes it simple for you to publish online your files. Once you're happy with a file, you can publish it to different hosting platforms like <b>Blogger</b>, <b>Dropbox</b>, <b>Gist</b>, <b>GitHub</b>, <b>Google Drive</b>, <b>WordPress</b> and <b>Zendesk</b>. With <a href="http://handlebarsjs.com/">Handlebars templates</a>, you have full control over what you export.</p>
<blockquote class="doxtable">
<p>Before starting to publish, you must link an account in the <b>Publish</b> sub-menu. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md97"></a>
Publish a File</h2>
<p>You can publish your file by opening the <b>Publish</b> sub-menu and by clicking <b>Publish to</b>. For some locations, you can choose between the following formats:</p>
<ul>
<li>Markdown: publish the Markdown text on a website that can interpret it (<b>GitHub</b> for instance),</li>
<li>HTML: publish the file converted to HTML via a Handlebars template (on a blog for example).</li>
</ul>
<h2><a class="anchor" id="autotoc_md98"></a>
Update a publication</h2>
<p>After publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the <b>Publish now</b> button in the navigation bar.</p>
<blockquote class="doxtable">
<p><b>Note:</b> The <b>Publish now</b> button is disabled if your file has not been published yet. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md99"></a>
Manage file publication</h2>
<p>Since one file can be published to multiple locations, you can list and manage publish locations by clicking <b>File publication</b> in the <b>Publish</b> sub-menu. This allows you to list and remove publication locations that are linked to your file.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Markdown extensions</h1>
<p>StackEdit extends the standard Markdown syntax by adding extra <b>Markdown extensions</b>, providing you with some nice features.</p>
<blockquote class="doxtable">
<p><b>ProTip:</b> You can disable any <b>Markdown extension</b> in the <b>File properties</b> dialog. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md101"></a>
SmartyPants</h2>
<p>SmartyPants converts ASCII punctuation characters into "smart" typographic punctuation HTML entities. For example:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">ASCII  </th><th class="markdownTableHeadNone">HTML   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Single backticks  </td><td class="markdownTableBodyNone">&lsquo;'Isn't this fun?&rsquo;&lsquo;  </td><td class="markdownTableBodyNone">'Isn't this fun?&rsquo;   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Quotes  </td><td class="markdownTableBodyNone"><code>"Isn't this fun?"</code>  </td><td class="markdownTableBodyNone">"Isn't this fun?"   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dashes  </td><td class="markdownTableBodyNone"><code>-- is en-dash, --- is em-dash</code>  </td><td class="markdownTableBodyNone">&ndash; is en-dash, &mdash; is em-dash   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md102"></a>
KaTeX</h2>
<p>You can render LaTeX mathematical expressions using <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p>
<p>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p>
<p>$$ \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. $$</p>
<blockquote class="doxtable">
<p>You can find more information about <b>LaTeX</b> mathematical expressions <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md103"></a>
UML diagrams</h2>
<p>You can render UML diagrams using <a href="https://mermaidjs.github.io/">Mermaid</a>. For example, this will produce a sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">Alice -&gt;&gt; Bob: Hello Bob, how are you?</div>
<div class="line">Bob--&gt;&gt;John: How about you John?</div>
<div class="line">Bob--x Alice: I am good thanks!</div>
<div class="line">Bob-x John: I am good thanks!</div>
<div class="line">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.</div>
<div class="line"> </div>
<div class="line">Bob--&gt;Alice: Checking with John...</div>
<div class="line">Alice-&gt;John: Yes... John, how are you?</div>
</div><!-- fragment --><p>And this will produce a flow chart:</p>
<div class="fragment"><div class="line">graph LR</div>
<div class="line">A[Square Rect] -- Link text --&gt; B((Circle))</div>
<div class="line">A --&gt; C(Round Rect)</div>
<div class="line">B --&gt; D{Rhombus}</div>
<div class="line">C --&gt; D</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassEThreadEventTimer_html"><div class="ttname"><a href="classEThreadEventTimer.html">EThreadEventTimer</a></div><div class="ttdoc">Thread timer class.</div><div class="ttdef"><b>Definition:</b> etevent.h:852</div></div>
<div class="ttc" id="aclassEThreadEvent_html_a3003651d73c57459305d073e0f1ad389"><div class="ttname"><a href="classEThreadEvent.html#a3003651d73c57459305d073e0f1ad389">EThreadEvent::onInit</a></div><div class="ttdeci">virtual Void onInit()</div><div class="ttdoc">Called in the context of the thread when the EM_INIT event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1182</div></div>
<div class="ttc" id="aclassEThreadQueuePublic_html"><div class="ttname"><a href="classEThreadQueuePublic.html">EThreadQueuePublic</a></div><div class="ttdoc">Definition of a public event thread message queue.</div><div class="ttdef"><b>Definition:</b> etevent.h:566</div></div>
<div class="ttc" id="aclassEThreadBasic_html_a2af11d0367222ca518151c21f543a6ec"><div class="ttname"><a href="classEThreadBasic.html#a2af11d0367222ca518151c21f543a6ec">EThreadBasic::threadProc</a></div><div class="ttdeci">virtual Dword threadProc(pVoid arg)=0</div><div class="ttdoc">Function that will be called in a separate thread.</div></div>
<div class="ttc" id="aclassETime_html_a18dad5deae22bfe316cad3171daca59c"><div class="ttname"><a href="classETime.html#a18dad5deae22bfe316cad3171daca59c">ETime::Now</a></div><div class="ttdeci">static ETime Now()</div><div class="ttdoc">Retrieves the current time.</div><div class="ttdef"><b>Definition:</b> etime.cpp:1148</div></div>
<div class="ttc" id="aclassEThreadEvent_html_ad9dbc8444a26b5865c399f5a075daf2c"><div class="ttname"><a href="classEThreadEvent.html#ad9dbc8444a26b5865c399f5a075daf2c">EThreadEvent::initTimer</a></div><div class="ttdeci">Void initTimer(EThreadEventTimer &amp;t)</div><div class="ttdoc">Intializes an EThreadEvent::Timer object and associates with this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1203</div></div>
<div class="ttc" id="aclassEThreadBasic_html_a94c06aeb1d4a549f367fda6d39c43a71"><div class="ttname"><a href="classEThreadBasic.html#a94c06aeb1d4a549f367fda6d39c43a71">EThreadBasic::sleep</a></div><div class="ttdeci">static Void sleep(Int milliseconds)</div><div class="ttdoc">Sleeps for the specified number of milliseconds.</div><div class="ttdef"><b>Definition:</b> etbasic.cpp:149</div></div>
<div class="ttc" id="aebase_8h_html_add3ca9eefe3b5b754426f51d3043e579"><div class="ttname"><a href="ebase_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></div><div class="ttdeci">#define True</div><div class="ttdoc">True.</div><div class="ttdef"><b>Definition:</b> ebase.h:25</div></div>
<div class="ttc" id="aclassEThreadMessage_html"><div class="ttname"><a href="classEThreadMessage.html">EThreadMessage</a></div><div class="ttdoc">An event message that is to be sent to a thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:266</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_a4b28f46b10c8164212e2713976f196b1"><div class="ttname"><a href="classEThreadEventTimer.html#a4b28f46b10c8164212e2713976f196b1">EThreadEventTimer::getId</a></div><div class="ttdeci">Long getId()</div><div class="ttdoc">Returns the unique timer id.</div><div class="ttdef"><b>Definition:</b> etevent.h:976</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html_aab7b01e9913284bd9af3d8d510ef892d"><div class="ttname"><a href="classEThreadEventMessageDataBase.html#aab7b01e9913284bd9af3d8d510ef892d">EThreadEventMessageDataBase::setVoidPtr</a></div><div class="ttdeci">virtual Void setVoidPtr(pVoid p)=0</div><div class="ttdoc">Sets the void pointer.</div></div>
<div class="ttc" id="aetevent_8h_html_a1fbc3aa077e4e82c9f1fa82d32653273"><div class="ttname"><a href="etevent_8h.html#a1fbc3aa077e4e82c9f1fa82d32653273">ON_MESSAGE</a></div><div class="ttdeci">#define ON_MESSAGE(id, memberFxn)</div><div class="ttdoc">Defines an invidual event handler.</div><div class="ttdef"><b>Definition:</b> etevent.h:818</div></div>
<div class="ttc" id="aclassEThreadEvent_html_adbdfea9c7c873363a05241dd166fa65b"><div class="ttname"><a href="classEThreadEvent.html#adbdfea9c7c873363a05241dd166fa65b">EThreadEvent::sendMessage</a></div><div class="ttdeci">Bool sendMessage(UInt message, Bool wait=True)</div><div class="ttdoc">Sends event message to this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1082</div></div>
<div class="ttc" id="aclassEThreadEvent_html_acc26ee3ebe6b5a0e18477c39c01b3c3a"><div class="ttname"><a href="classEThreadEvent.html#acc26ee3ebe6b5a0e18477c39c01b3c3a">EThreadEvent::onTimer</a></div><div class="ttdeci">virtual Void onTimer(EThreadEventTimer *ptimer)</div><div class="ttdoc">Called in the context of the thread when th EM_TIMER event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1197</div></div>
<div class="ttc" id="aclassEThreadEvent_html"><div class="ttname"><a href="classEThreadEvent.html">EThreadEvent</a></div><div class="ttdoc">base class for EThreadPrivate and EThreadPublic</div><div class="ttdef"><b>Definition:</b> etevent.h:1040</div></div>
<div class="ttc" id="aclassEThreadEventMessageBase_html"><div class="ttname"><a href="classEThreadEventMessageBase.html">EThreadEventMessageBase</a></div><div class="ttdoc">A template class that all event message classes should derive from.</div><div class="ttdef"><b>Definition:</b> etevent.h:206</div></div>
<div class="ttc" id="aclassEThreadEvent_html_a18fbce94b1fdc44d69cac2ca712fb90e"><div class="ttname"><a href="classEThreadEvent.html#a18fbce94b1fdc44d69cac2ca712fb90e">EThreadEvent::onQuit</a></div><div class="ttdeci">virtual Void onQuit()</div><div class="ttdoc">Called in the context of the thread when the EM_QUIT event is processed.</div><div class="ttdef"><b>Definition:</b> etevent.h:1186</div></div>
<div class="ttc" id="aetevent_8h_html_a0c8d25bf6492235c4f7f47ee387698ae"><div class="ttname"><a href="etevent_8h.html#a0c8d25bf6492235c4f7f47ee387698ae">BEGIN_MESSAGE_MAP</a></div><div class="ttdeci">#define BEGIN_MESSAGE_MAP(theClass, baseClass)</div><div class="ttdoc">Begins the message map declaration.</div><div class="ttdef"><b>Definition:</b> etevent.h:803</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_ab95bdb5c96b1ebe5662785282584dbab"><div class="ttname"><a href="classEThreadEventTimer.html#ab95bdb5c96b1ebe5662785282584dbab">EThreadEventTimer::setInterval</a></div><div class="ttdeci">Void setInterval(Long interval)</div><div class="ttdoc">sets the timer interval</div><div class="ttdef"><b>Definition:</b> etevent.h:964</div></div>
<div class="ttc" id="aclassESharedMemory_html_affda2d92d4ba4506b196d7c266b777ad"><div class="ttname"><a href="classESharedMemory.html#affda2d92d4ba4506b196d7c266b777ad">ESharedMemory::getDataPtr</a></div><div class="ttdeci">pVoid getDataPtr()</div><div class="ttdoc">Retrieves a pointer to the first location of the shated memory.</div><div class="ttdef"><b>Definition:</b> eshmem.h:65</div></div>
<div class="ttc" id="aclassESharedMemory_html_ad231d66f0e4d22240690008d6131cff7"><div class="ttname"><a href="classESharedMemory.html#ad231d66f0e4d22240690008d6131cff7">ESharedMemory::init</a></div><div class="ttdeci">Void init(cpStr file, Int id, Int size)</div><div class="ttdoc">Initializes this shared memory object. This method is called by the parameterized constructor.</div><div class="ttdef"><b>Definition:</b> eshmem.cpp:109</div></div>
<div class="ttc" id="aebase_8h_html_a306ebd41c0cd1303b1372c6153f0caf8"><div class="ttname"><a href="ebase_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></div><div class="ttdeci">#define False</div><div class="ttdoc">False.</div><div class="ttdef"><b>Definition:</b> ebase.h:27</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_a6c65cb3297ebc6b37d0aaf8b38445ece"><div class="ttname"><a href="classEThreadEventTimer.html#a6c65cb3297ebc6b37d0aaf8b38445ece">EThreadEventTimer::setOneShot</a></div><div class="ttdeci">Void setOneShot(Bool oneshot)</div><div class="ttdoc">sets the type of timer</div><div class="ttdef"><b>Definition:</b> etevent.h:969</div></div>
<div class="ttc" id="aclassEThreadEvent_html_abd80672a331041d46982c9c7f873cdc1"><div class="ttname"><a href="classEThreadEvent.html#abd80672a331041d46982c9c7f873cdc1">EThreadEvent::init</a></div><div class="ttdeci">virtual Void init(Short appId, UShort threadId, pVoid arg, Int queueSize=16384, Bool suspended=False, Dword stackSize=0)</div><div class="ttdoc">Initializes the thread object.</div><div class="ttdef"><b>Definition:</b> etevent.h:1133</div></div>
<div class="ttc" id="aclassETime_html_a7c794038cc4ca2f0c9cffbf9e5a2bbee"><div class="ttname"><a href="classETime.html#a7c794038cc4ca2f0c9cffbf9e5a2bbee">ETime::Format</a></div><div class="ttdeci">Void Format(EString &amp;dest, cpStr fmt, Bool local)</div><div class="ttdoc">Formats the date/time value as specified by the format string.</div><div class="ttdef"><b>Definition:</b> etime.cpp:1158</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html"><div class="ttname"><a href="classEThreadEventMessageDataBase.html">EThreadEventMessageDataBase</a></div><div class="ttdoc">The base class that all event message data objects should be derived from.</div><div class="ttdef"><b>Definition:</b> etevent.h:56</div></div>
<div class="ttc" id="aclassESharedMemory_html"><div class="ttname"><a href="classESharedMemory.html">ESharedMemory</a></div><div class="ttdoc">The shared memory access class.</div><div class="ttdef"><b>Definition:</b> eshmem.h:43</div></div>
<div class="ttc" id="aclassEThreadEventMessageDataBase_html_a54bf958a39d811cd2d2dac47eb842d22"><div class="ttname"><a href="classEThreadEventMessageDataBase.html#a54bf958a39d811cd2d2dac47eb842d22">EThreadEventMessageDataBase::getVoidPtr</a></div><div class="ttdeci">virtual pVoid getVoidPtr()=0</div><div class="ttdoc">Retrieves the void pointer.</div></div>
<div class="ttc" id="aclassEThreadEventTimer_html_afe96e27e5031ae396f1f66160fb9e0ad"><div class="ttname"><a href="classEThreadEventTimer.html#afe96e27e5031ae396f1f66160fb9e0ad">EThreadEventTimer::start</a></div><div class="ttdeci">Void start()</div><div class="ttdoc">Starts the timer.</div><div class="ttdef"><b>Definition:</b> etevent.h:932</div></div>
<div class="ttc" id="aclassEThreadBasic_html"><div class="ttname"><a href="classEThreadBasic.html">EThreadBasic</a></div><div class="ttdoc">An abstract class that represents contains the threadProc() that will be run in a separate thread.</div><div class="ttdef"><b>Definition:</b> etbasic.h:53</div></div>
<div class="ttc" id="aetevent_8h_html_ae52a1e808bcf6220acbef40e8351b8e7"><div class="ttname"><a href="etevent_8h.html#ae52a1e808bcf6220acbef40e8351b8e7">END_MESSAGE_MAP</a></div><div class="ttdeci">#define END_MESSAGE_MAP()</div><div class="ttdoc">Ends the message map declaration.</div><div class="ttdef"><b>Definition:</b> etevent.h:822</div></div>
<div class="ttc" id="aetevent_8h_html_a3e0395c0f948348673c39d06c8bd12bf"><div class="ttname"><a href="etevent_8h.html#a3e0395c0f948348673c39d06c8bd12bf">DECLARE_MESSAGE_MAP</a></div><div class="ttdeci">#define DECLARE_MESSAGE_MAP()</div><div class="ttdoc">Inserts message map declarations into the thread class.</div><div class="ttdef"><b>Definition:</b> etevent.h:793</div></div>
<div class="ttc" id="aclassEThreadEvent_html_ad9c48af1f8f68bc7631c547ff2f31757"><div class="ttname"><a href="classEThreadEvent.html#ad9c48af1f8f68bc7631c547ff2f31757">EThreadEvent::quit</a></div><div class="ttdeci">Void quit()</div><div class="ttdoc">Posts the quit message to this thread.</div><div class="ttdef"><b>Definition:</b> etevent.h:1149</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
